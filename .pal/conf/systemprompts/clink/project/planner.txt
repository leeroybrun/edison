=== Edison / Pal Prompt ===
Role: planner


# Tech-Stack Pack Contexts

<!-- MANDATORY READ: {{PROJECT_EDISON_DIR}}/core/guidelines/validators/TECH_STACK_CONTEXT.md -->



**Note**: This validator uses tech-stack guidelines from the shared context file.

The composition engine replaces inline pack duplication with this reference to reduce

prompt size and maintain DRY principles across all validators.

=== Role-Specific Guidelines ===

## Guideline: edison/ARCHITECTURE

# Edison Architecture Guide

This guide documents Edison's architecture and patterns for contributors.

---

## Overview

Edison is an AI-automated project management framework with:

- **Multi-agent orchestration** - Orchestrator, Agents, Validators
- **Session-based isolation** - Git worktrees per session
- **Configuration-driven behavior** - All settings from YAML
- **Layered composition** - Core → Packs → Project

---

## Module Structure

```
src/edison/
├── cli/                        # CLI layer (auto-discovered)
│   ├── _dispatcher.py          # Command dispatcher
│   ├── session/                # Session commands
│   ├── task/                   # Task commands
│   ├── qa/                     # QA commands
│   ├── compose/                # Composition commands
│   ├── config/                 # Config commands
│   └── orchestrator/           # Orchestrator commands
│
├── core/                       # Core business logic
│   ├── config/                 # Configuration system
│   │   ├── manager.py         # Config loading/merging
│   │   └── domains/           # Domain-specific accessors
│   ├── entity/                 # Entity framework
│   │   ├── base.py            # BaseEntity class
│   │   └── repository.py      # Generic repository
│   ├── state/                  # State machine engine
│   │   ├── machine.py         # RichStateMachine
│   │   └── validator.py       # State transition validator
│   ├── session/                # Session domain
│   │   ├── core/              # Models
│   │   ├── lifecycle/         # Creation, closing
│   │   ├── persistence/       # Storage
│   │   └── worktree/          # Git worktree management
│   ├── task/                   # Task domain
│   ├── qa/                     # QA/validation domain
│   │   ├── validator/         # Validator execution
│   │   └── evidence/          # Evidence collection
│   ├── composition/            # Composition engine
│   │   ├── core/              # LayeredComposer
│   │   └── registries/        # Agent/Validator registries
│   └── utils/                  # Shared utilities
│
└── data/                       # Bundled data
    ├── config/                 # YAML configurations
    ├── packs/                  # Technology packs
    ├── agents/                 # Agent definitions
    ├── validators/             # Validator definitions
    ├── guidelines/             # Guideline documents
    └── constitutions/          # Role constitutions
```

---

## Key Patterns

### 1. Auto-Discovery Pattern

CLI commands are auto-discovered from the filesystem:

```python
# src/edison/cli/_dispatcher.py
def discover_domains() -> list[str]:
    """Auto-discover domain folders in cli/."""
    cli_dir = Path(__file__).parent
    return [d.name for d in cli_dir.iterdir() if d.is_dir() and not d.name.startswith("_")]

def discover_commands(domain: str) -> list[str]:
    """Auto-discover command files in domain folder."""
    domain_dir = Path(__file__).parent / domain
    return [f.stem for f in domain_dir.glob("*.py") if not f.name.startswith("_")]
```

**Adding a new command:**
1. Create `src/edison/cli/{domain}/{command}.py`
2. Implement `register_args()` and `main()`
3. Command auto-discovered on next run

---

### 2. Configuration Pattern

All configuration from YAML, accessed via domain classes:

```python
# src/edison/core/config/manager.py
class ConfigManager:
    def load_config(self) -> dict:
        """Load and merge bundled + project config."""
        bundled = self._load_bundled_config()
        project = self._load_project_config()
        return deep_merge(bundled, project)

# src/edison/core/config/domains/qa.py
class QAConfig(BaseDomainConfig):
    @cached_property
    def validator_timeout(self) -> int:
        return self.section.get("execution", {}).get("timeout", 300)
```

**Adding new configuration:**
1. Add YAML to `src/edison/data/config/`
2. Create domain accessor in `src/edison/core/config/domains/`
3. Use accessor in code (never hardcode)

---

### 3. Entity Pattern

All entities inherit from BaseEntity with state machine:

```python
from dataclasses import dataclass, field
from edison.core.entity import BaseEntity
from edison.core.state import StateValidator

@dataclass
class Task(BaseEntity):
    title: str
    status: str = "pending"
    state_history: list = field(default_factory=list)

    def transition_to(self, new_state: str) -> None:
        """Transition with state machine validation."""
        StateValidator.ensure_transition("task", self.status, new_state)
        self.record_transition(self.status, new_state)
        self.status = new_state

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "title": self.title,
            "status": self.status,
            "state_history": self.state_history,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "Task":
        return cls(**data)
```

---

### 4. State Machine Pattern

States defined in YAML, transitions validated:

```yaml
# src/edison/data/config/state-machine.yaml
task:
  states:
    - pending
    - in_progress
    - completed
    - blocked
  transitions:
    - from: pending
      to: in_progress
      guards: [task_claimed]
    - from: in_progress
      to: completed
      guards: [tests_passing]
```

```python
# Usage
from edison.core.state import StateValidator

StateValidator.ensure_transition("task", "pending", "in_progress")
# Raises StateTransitionError if invalid
```

---

### 5. Composition Pattern

Layered composition with section markers:

```markdown
# Base file (src/edison/data/agents/feature-implementer.md)
## Tools
{{SECTION:Tools}}

## Guidelines
{{SECTION:Guidelines}}
```

```markdown
# Overlay file (packs/python/agents/overlays/feature-implementer.md)

### Python Tools
- pytest, mypy, ruff

### Python Guidelines
- Use type hints

```

**Composition order:**
1. Core (bundled defaults)
2. Active packs (technology-specific)
3. Project overlays (project-specific)

---

## Data Flow

```
User Input → CLI Command → Core Service → Repository → File System
                ↓
         Config Manager → YAML Files
                ↓
         State Machine → Guards/Conditions
                ↓
         Entity → State History
```

---

## Adding New Features

### New CLI Command

1. Create file: `src/edison/cli/{domain}/{command}.py`
2. Implement required functions:
   ```python
   def register_args(parser: argparse.ArgumentParser) -> None:
       parser.add_argument("--flag", help="Description")

   def main(args: argparse.Namespace) -> int:
       # Implementation
       return 0
   ```
3. Add tests: `tests/unit/cli/test_{command}.py`

### New Entity

1. Create model: `src/edison/core/{domain}/models.py`
2. Inherit from BaseEntity
3. Add state machine config if needed
4. Create repository: `src/edison/core/{domain}/repository.py`
5. Add tests

### New Pack

1. Copy template: `cp -r src/edison/data/packs/_template src/edison/data/packs/new_pack`
2. Edit `pack.yml` with triggers
3. Create overlays for agents/validators
4. Add guidelines and examples
5. Run `edison compose all`

### New Configuration

1. Create/edit YAML in `src/edison/data/config/`
2. Create domain accessor
3. Add JSON schema if needed
4. Update documentation

---

## Testing Patterns

```python
# Use real files
def test_load_config(tmp_path: Path):
    config_file = tmp_path / "config.yaml"
    config_file.write_text("key: value\n")

    config = load_config(config_file)

    assert config["key"] == "value"

# No mocks - real database
@pytest.fixture
def task_repo(tmp_path: Path):
    return FileTaskRepository(tmp_path)

def test_save_load(task_repo):
    task = Task(id="1", title="Test")
    task_repo.save(task)

    loaded = task_repo.get("1")
    assert loaded.title == "Test"
```

---

## Critical Principles (from CLAUDE.md)

1. **STRICT TDD** - Tests first, always
2. **NO MOCKS** - Real behavior only
3. **NO HARDCODING** - Config from YAML
4. **DRY** - No duplication
5. **SOLID** - Clean architecture
6. **ROOT CAUSE** - Fix underlying issues

---

## Directory Reference

| Path | Purpose |
|------|---------|
| `src/edison/cli/` | CLI commands (auto-discovered) |
| `src/edison/core/` | Business logic |
| `src/edison/data/config/` | YAML configurations |
| `src/edison/data/packs/` | Technology packs |
| `src/edison/data/agents/` | Agent definitions |
| `src/edison/data/validators/` | Validator definitions |
| `.edison/config/` | Project overrides |
| `.edison/_generated/` | Composed artifacts |
| `.project/` | Runtime data (sessions, tasks, QA) |
| `tests/` | Test suite |

## Guideline: includes/TASK_PLANNING

# Task Waves (Parallelizable Waves) - Include-Only File
<!-- WARNING: This file is for {{include-section:}} only. DO NOT read directly. -->

<!-- section: orchestrator-step-snippet -->
## orchestrator-step-snippet

Compute parallelizable “waves” from `depends_on`:

```bash
edison task waves
```

<!-- section: orchestrator-cli-snippet -->
## orchestrator-cli-snippet

### Task Waves (Parallelizable Waves)

```bash
edison task waves [--json] [--cap <n>]
```

**Purpose**: Compute topological “waves” of **todo** tasks based on `depends_on`, so you can safely delegate independent work in parallel without reading every task file.

**How to use**:
- Prefer **Wave 1** tasks for “start now”.
- Respect the configured cap (`orchestration.maxConcurrentAgents`). Use `--json` only when you need structured batches for tools/scripts.
- Use `edison task blocked` for detailed “why blocked” explanations on a specific task.
<!-- /section: orchestrator-cli-snippet -->

<!-- section: orchestrator-constitution-snippet -->
## orchestrator-constitution-snippet

Use `edison task waves` to compute parallelizable waves of todo tasks from `depends_on` (Wave 1 = “start now”), and respect `orchestration.maxConcurrentAgents`. Use `edison task blocked <task-id>` for “why blocked” explanations.
<!-- /section: orchestrator-constitution-snippet -->

## Role-Specific Rules
- [NON-BLOCKING] Preserve context budget – load only what's needed (category: context)
- [NON-BLOCKING] Share snippets not whole files in prompts (category: context)
- [NON-BLOCKING] Delegation Decision Priority Chain (category: delegation)
- [NON-BLOCKING] Disallow skipping states in task/QA transitions (category: transition)
- [NON-BLOCKING] Do not load big files unless necessary (category: context)
- [NON-BLOCKING] Delegate the majority of work (category: delegation)
- [NON-BLOCKING] Session-scoped file isolation is mandatory (category: session)
- [NON-BLOCKING] No manual file moves; use guarded CLIs (category: transition)
- [NON-BLOCKING] Context7 Required For Post-Training Packages (category: context)
- [NON-BLOCKING] Fail-Closed: All Moves Through Guarded Python CLIs (category: transition)
- [NON-BLOCKING] Orchestrator should parallelize via tasks/split for non-trivial tasks (category: delegation)
- [NON-BLOCKING] Close session only when no blockers remain and all scope is validated (category: session)
- [NON-BLOCKING] Session completion: parent validated; children done|validated (category: session)
- [NON-BLOCKING] Drive execution via session next (loop driver) (category: session)
- [NON-BLOCKING] Sub-agents must not re-delegate (category: delegation)

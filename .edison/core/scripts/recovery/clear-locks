#!/usr/bin/env python3
"""
Wrapper script for clearing stale locks.
Maps legacy script interface to Python module: edison.core.session.lifecycle.recovery
"""
import sys
import argparse
import os
from pathlib import Path

# Ensure edison package is importable
REPO_ROOT = Path(__file__).resolve().parents[4]
if str(REPO_ROOT / "src") not in sys.path:
    sys.path.insert(0, str(REPO_ROOT / "src"))

from edison.core.session.lifecycle.recovery import clear_all_locks
from edison.core.utils.paths import PathResolver


def main():
    parser = argparse.ArgumentParser(description="Clear stale lock files")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be removed without removing")
    parser.add_argument("--force", action="store_true", help="Force remove all locks")
    parser.add_argument("--max-age", type=int, default=60, help="Max age in minutes (unused, for compatibility)")
    args = parser.parse_args()

    # Set project root from environment if provided
    if "AGENTS_PROJECT_ROOT" in os.environ:
        PathResolver._project_root_override = Path(os.environ["AGENTS_PROJECT_ROOT"])

    try:
        # Get project root
        try:
            root = PathResolver.resolve_project_root()
        except (FileNotFoundError, OSError, RuntimeError) as e:
            print(f"Error: Failed to resolve project root: {e}", file=sys.stderr)
            return 1

        # Find all .lock files in .project directory
        project_dir = root / ".project"
        if not project_dir.exists():
            print("No .project directory found")
            return 0

        # Scan for .lock files in tasks, qa, and locks directories
        lock_files = []
        for pattern in ["tasks/**/*.lock", "qa/**/*.lock", "locks/**/*.lock"]:
            lock_files.extend(project_dir.glob(pattern))

        if not lock_files:
            print("No lock files found")
            return 0

        # Filter by age and check if PID is active
        import time
        max_age_seconds = args.max_age * 60
        stale_locks = []

        def is_pid_active(pid: int) -> bool:
            """Check if a process with given PID is running."""
            try:
                os.kill(pid, 0)
                return True
            except (OSError, ProcessLookupError):
                return False

        def get_lock_pid(lock_file: Path) -> int | None:
            """Extract PID from lock file if present."""
            try:
                content = lock_file.read_text()
                for line in content.splitlines():
                    if line.startswith("pid="):
                        return int(line.split("=", 1)[1].strip())
            except (OSError, ValueError):
                pass
            return None

        for lock_file in lock_files:
            try:
                mtime = lock_file.stat().st_mtime
                age_seconds = time.time() - mtime
                if age_seconds > max_age_seconds:
                    # Check if PID is still active
                    pid = get_lock_pid(lock_file)
                    if pid is not None and is_pid_active(pid):
                        # Skip active PIDs
                        continue
                    stale_locks.append(lock_file)
            except OSError:
                continue

        if not stale_locks:
            print("No stale lock files found")
            return 0

        if args.dry_run:
            # In dry-run mode, list what would be cleared
            print(f"Found {len(stale_locks)} stale lock(s):")
            for lock in stale_locks:
                rel_path = lock.relative_to(root)
                print(f"  {rel_path}")
            return 0

        # Actually clear locks
        cleared_count = 0
        for lock_file in stale_locks:
            try:
                lock_file.unlink()
                cleared_count += 1
                rel_path = lock_file.relative_to(root)
                print(f"Cleared: {rel_path}")
            except OSError as e:
                print(f"Warning: Failed to remove {lock_file}: {e}", file=sys.stderr)

        if cleared_count > 0:
            print(f"\nCleared {cleared_count} stale lock(s)")
        else:
            print("No locks cleared")
        return 0

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())

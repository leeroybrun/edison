#!/usr/bin/env python3
"""
Wrapper script for cleaning orphaned git worktrees.
Detects worktrees without corresponding sessions and archives them.
"""
import sys
import argparse
import os
import json
import shutil
import subprocess
from pathlib import Path
from datetime import datetime

# Ensure edison package is importable
REPO_ROOT = Path(__file__).resolve().parents[4]
if str(REPO_ROOT / "src") not in sys.path:
    sys.path.insert(0, str(REPO_ROOT / "src"))

from edison.core.utils.paths import PathResolver


def get_worktree_config(root: Path) -> dict:
    """Load worktree configuration from .agents/manifest.json or config.yml."""
    # Try manifest.json first
    manifest_path = root / ".agents" / "manifest.json"
    if manifest_path.exists():
        try:
            with open(manifest_path, 'r') as f:
                manifest = json.load(f)
                if "worktrees" in manifest:
                    return manifest["worktrees"]
        except (json.JSONDecodeError, OSError):
            pass

    # Default configuration
    project_name = os.environ.get("PROJECT_NAME", "example-project")
    return {
        "enabled": True,
        "baseDirectory": f"../{project_name}-worktrees",
        "archiveDirectory": f"../{project_name}-worktrees/_archived",
        "branchPrefix": "session/",
        "baseBranch": "main",
    }


def list_git_worktrees(repo_root: Path) -> list[dict]:
    """List all git worktrees."""
    try:
        result = subprocess.run(
            ["git", "worktree", "list", "--porcelain"],
            cwd=repo_root,
            capture_output=True,
            text=True,
            check=True
        )

        worktrees = []
        current = {}
        for line in result.stdout.splitlines():
            if line.startswith("worktree "):
                if current:
                    worktrees.append(current)
                current = {"path": Path(line.split(" ", 1)[1])}
            elif line.startswith("branch "):
                current["branch"] = line.split(" ", 1)[1]
            elif line.startswith("bare"):
                current["bare"] = True

        if current:
            worktrees.append(current)

        return worktrees
    except subprocess.CalledProcessError:
        return []


def get_active_sessions(root: Path) -> set[str]:
    """Get set of active session IDs."""
    sessions = set()
    sessions_dir = root / ".project" / "sessions"

    if not sessions_dir.exists():
        return sessions

    # Check all state directories
    for state_dir in sessions_dir.iterdir():
        if not state_dir.is_dir() or state_dir.name.startswith("_"):
            continue

        for session_file in state_dir.glob("*.json"):
            sessions.add(session_file.stem)

    return sessions


def main():
    parser = argparse.ArgumentParser(description="Clean orphaned git worktrees")
    parser.add_argument("--dry-run", action="store_true", help="Show orphans without cleaning")
    parser.add_argument("--force", action="store_true", help="Force clean orphaned worktrees")
    args = parser.parse_args()

    # Set project root from environment if provided
    if "AGENTS_PROJECT_ROOT" in os.environ:
        root = Path(os.environ["AGENTS_PROJECT_ROOT"])
    else:
        try:
            root = PathResolver.resolve_project_root()
        except (FileNotFoundError, OSError, RuntimeError) as e:
            print(f"Error: Failed to resolve project root: {e}", file=sys.stderr)
            return 1

    try:
        config = get_worktree_config(root)

        if not config.get("enabled"):
            print("Worktrees not enabled")
            return 0

        # Get worktrees and active sessions
        worktrees = list_git_worktrees(root)
        active_sessions = get_active_sessions(root)

        # Find orphans
        branch_prefix = config.get("branchPrefix", "session/")
        orphans = []

        for wt in worktrees:
            branch = wt.get("branch", "")
            if not branch.startswith(f"refs/heads/{branch_prefix}"):
                continue

            # Extract session ID from branch name
            session_id = branch.replace(f"refs/heads/{branch_prefix}", "")

            # Check if session exists
            if session_id not in active_sessions:
                # Check for .keep file
                wt_path = wt["path"]
                if (wt_path / ".keep").exists():
                    continue

                orphans.append({
                    "session_id": session_id,
                    "path": wt_path,
                    "branch": branch
                })

        if not orphans:
            print("No orphaned worktrees found")
            return 0

        if args.dry_run:
            print(f"Found {len(orphans)} orphaned worktree(s):")
            for orphan in orphans:
                print(f"  {orphan['session_id']}: {orphan['path']}")
            return 0

        # Archive orphans
        base_dir_rel = config.get("baseDirectory", "")
        archive_dir_rel = config.get("archiveDirectory", "")

        # Resolve archive directory
        # archiveDirectory in manifest/config uses paths relative to repo root
        # If it starts with "../", it's relative to repo parent
        if archive_dir_rel.startswith("../"):
            # Remove leading "../" and resolve from repo parent
            rel_path = archive_dir_rel[3:]  # Remove "../"
            archive_dir = (root.parent / rel_path).resolve()
        else:
            archive_dir = (root / archive_dir_rel).resolve()

        archive_dir.mkdir(parents=True, exist_ok=True)

        for orphan in orphans:
            session_id = orphan["session_id"]
            wt_path = orphan["path"]

            # Archive the directory BEFORE removing worktree
            # git worktree remove will delete the directory, so we need to move it first
            if wt_path.exists():
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                archive_name = f"{session_id}_{timestamp}"
                archive_path = archive_dir / archive_name

                # Move directory to archive first
                shutil.move(str(wt_path), str(archive_path))
                print(f"Archived orphan {session_id} to {archive_path}")

            # Remove worktree from git (this will fail if directory already moved, but that's ok)
            try:
                subprocess.run(
                    ["git", "worktree", "remove", str(wt_path), "--force"],
                    cwd=root,
                    capture_output=True,
                    check=False  # Don't fail if already removed
                )
            except subprocess.CalledProcessError as e:
                # This is expected if we already moved the directory
                pass

        return 0

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())

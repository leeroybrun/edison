# Edison Context Window Anxiety Management (CWAM)

CWAM is Edison's system for managing context window limits in AI agents. It provides strategies for truncation, compaction, and reminders to prevent context overflow errors and maintain agent productivity.

---

## Table of Contents

1. [Overview](#overview)
2. [Why CWAM?](#why-cwam)
3. [Core Strategies](#core-strategies)
4. [Configuration](#configuration)
5. [OpenCode Plugin Features](#opencode-plugin-features)
6. [Rules and Guidance](#rules-and-guidance)
7. [Best Practices](#best-practices)

---

## Overview

Context Window Anxiety Management addresses the challenges of working with limited context windows in LLMs:

- **Truncation**: Prevent large outputs from consuming excessive context
- **Preemptive compaction**: Compact before hitting limits
- **Recovery compaction**: Recover gracefully from token-limit errors
- **Reminders**: Gentle reminders to agents about context budget
- **Summary guidance**: Shape compaction summaries to preserve critical state

**Source of truth:**
- Configuration: `src/edison/data/config/context_window.yaml`
- Rules: `RULE.CONTEXT.*` in `src/edison/data/rules/registry.yml`
- Plugin: `.opencode/plugin/edison.ts` (generated by `edison opencode setup`)

---

## Why CWAM?

AI agents often face context window limits:

| Problem | Impact |
|---------|--------|
| Tool outputs too large | Context fills up quickly |
| No proactive compaction | Agent hits limit mid-task |
| Token-limit errors | Agent crashes or loses state |
| Context bloat | Agent forgets early context |
| Anxiety about limits | Agent wastes tokens worrying |

CWAM addresses each of these systematically.

---

## Core Strategies

### 1. Output Truncation

Large tool outputs are truncated to prevent context bloat:

```yaml
context_window:
  truncation:
    enabled: false
    maxChars: 20000
    headerLines: 30
    notice: "[truncated by Edison]"
```

**How it works:**
- Tool outputs exceeding `maxChars` are truncated
- First `headerLines` lines are preserved as headers
- A truncation notice is appended
- Original output is still available in files

**Example:**
```
$ npm test
PASS src/tests/unit/foo.test.ts
PASS src/tests/unit/bar.test.ts
... 30 more header lines ...

[truncated by Edison]
```

### 2. Preemptive Compaction

Compact context before hitting limits:

```yaml
context_window:
  compaction:
    preemptive:
      enabled: true
      threshold: 0.70
      cooldownSeconds: 120
```

**How it works:**
- Plugin estimates token usage (chars / 4 heuristic)
- At 70% of estimated limit, triggers compaction
- Minimum 2 minutes between preemptive compactions
- Edison context is re-injected after compaction

### 3. Recovery Compaction

Recover from token-limit errors:

```yaml
context_window:
  compaction:
    recovery:
      enabled: true
      maxAttempts: 3
      errorPatterns:
        - "context.length"
        - "token.*limit"
        - "context.*too.*long"
        - "max.*tokens"
        - "context.*window"
        - "rate.*limit.*tokens"
```

**How it works:**
- Plugin monitors for token-limit errors
- On match, triggers compaction automatically
- Re-injects Edison session context
- Retries up to `maxAttempts` times
- Fails open if recovery exhausted

### 4. Compaction Hooks

Edison integrates with OpenCode's compaction lifecycle:

```typescript
// Before compaction: inject summary-shape guidance
"experimental.session.compacting": async (input, output) => {
  const rulesPayload = await fetchEdisonRulesInject("compaction");
  if (rulesPayload?.injection) {
    output.context.push(rulesPayload.injection);
  }
}

// After compaction: re-inject Edison context
event: async ({ event }) => {
  if (event.type === "session.compacted") {
    const contextOutput = await fetchEdisonSessionContext();
    if (contextOutput) {
      await client.session.prompt({ noReply: true, text: contextOutput });
    }
  }
}
```

### 5. Context Reminders

Gentle reminders injected into continuation prompts:

```yaml
context_window:
  reminders:
    enabled: true
```

**Example prompt:**
```
Continue working until the Edison session is complete.
Use the loop driver: `edison session next my-session`
CWAM: Keep context budget under control - prefer snippets over whole files.
```

---

## Configuration

### Full Configuration Reference

```yaml
# src/edison/data/config/context_window.yaml

context_window:
  enabled: true

  # Reminders in continuation prompts
  reminders:
    enabled: true

  # Prompt injection settings
  prompts:
    inject: true
    ruleContext: context_window

  # Output truncation
  truncation:
    enabled: false
    maxChars: 20000
    headerLines: 30
    notice: "[truncated by Edison]"

  # Compaction settings
  compaction:
    # Rule ID for summary-shape guidance
    summaryShapeRuleId: RULE.CONTEXT.CWAM_REASSURANCE

    # Preemptive compaction
    preemptive:
      enabled: true
      threshold: 0.70
      cooldownSeconds: 120

    # Recovery compaction
    recovery:
      enabled: true
      maxAttempts: 3
      errorPatterns:
        - "context.length"
        - "token.*limit"
        - "context.*too.*long"
        - "max.*tokens"
        - "context.*window"
        - "rate.*limit.*tokens"
```

### Project Overrides

Create `.edison/config/context_window.yaml`:

```yaml
context_window:
  truncation:
    maxChars: 50000  # Larger budget for this project
  compaction:
    preemptive:
      threshold: 0.80  # Compact later
```

---

## OpenCode Plugin Features

The Edison OpenCode plugin implements CWAM features:

### Truncation

```typescript
function truncateToolOutput(output: string): string {
  if (output.length <= TRUNCATION_CONFIG.maxChars) {
    return output;
  }

  const lines = output.split("\n");
  const headerLines = lines.slice(0, TRUNCATION_CONFIG.preserveHeaderLines);
  const headerText = headerLines.join("\n");

  const remainingBudget = TRUNCATION_CONFIG.maxChars - headerText.length;
  const remainingText = lines.slice(TRUNCATION_CONFIG.preserveHeaderLines).join("\n");
  const truncatedRemaining = remainingText.slice(0, remainingBudget);

  return headerText + "\n" + truncatedRemaining + TRUNCATION_CONFIG.truncationNotice;
}
```

### Token Usage Tracking

```typescript
function updateTokenUsage(compactionState: CompactionState, textLength: number): void {
  // Heuristic: 4 chars = 1 token
  const estimatedTokens = Math.ceil(textLength / 4);
  compactionState.estimatedTokenUsage += estimatedTokens;
}
```

### Preemptive Compaction Check

```typescript
function shouldTriggerPreemptiveCompaction(state: CompactionState): boolean {
  const usageRatio = state.estimatedTokenUsage / COMPACTION_CONFIG.preemptive.estimatedTokenLimit;
  return usageRatio >= COMPACTION_CONFIG.preemptive.threshold;
}
```

### Recovery on Error

```typescript
if (event.type === "session.error") {
  if (isTokenLimitError(event.error)) {
    if (state.recoveryAttempts < COMPACTION_CONFIG.recovery.maxAttempts) {
      state.recoveryAttempts++;
      await performCompaction(client, sessionId, state);
    }
  }
}
```

---

## Rules and Guidance

### RULE.CONTEXT.CWAM_REASSURANCE

Provides reassurance and guidance during compaction:

```yaml
- id: RULE.CONTEXT.CWAM_REASSURANCE
  title: Context window anxiety management (CWAM)
  category: context
  blocking: false
  guidance: |
    Keep context budget under control by preferring concise summaries and diffs
    over full files. When compaction occurs, preserve:
    - Current session state and active task
    - Recent actions and their outcomes
    - Key decisions and rationale
    - Next steps and blockers
```

### RULE.CONTEXT.BUDGET_MINIMIZE

Encourages minimal context loading:

```yaml
- id: RULE.CONTEXT.BUDGET_MINIMIZE
  title: Preserve context budget - load only what's needed
  category: context
  blocking: false
  guidance: |
    Load only the minimum files/sections necessary for the current decision.
    Prefer diffs + focused snippets over whole files.
```

### RULE.CONTEXT.NO_BIG_FILES

Warns against loading large files:

```yaml
- id: RULE.CONTEXT.NO_BIG_FILES
  title: Do not load big files unless necessary
  category: context
  blocking: false
  guidance: |
    Avoid loading very large files (logs, generated artefacts, bundled assets)
    into prompts. Extract only the minimal relevant excerpt.
```

### RULE.CONTEXT.SNIPPET_ONLY

Encourages snippets over whole files:

```yaml
- id: RULE.CONTEXT.SNIPPET_ONLY
  title: Share snippets not whole files in prompts
  category: context
  blocking: false
  guidance: |
    Send focused snippets around the change (functions, components, paragraphs)
    instead of whole files. Combine multiple small snippets when needed.
```

---

## Best Practices

### For Agents

1. **Prefer snippets**: Load only the code/text you need
2. **Use diffs**: `git diff` instead of full file contents
3. **Summarize outputs**: Extract key information from large outputs
4. **Clean up**: Remove stale context when no longer needed
5. **Trust CWAM**: Let the system handle compaction gracefully

### For Configuration

1. **Tune thresholds**: Adjust based on your model's context limit
2. **Monitor patterns**: Add error patterns for your provider
3. **Test compaction**: Verify context is properly restored
4. **Balance truncation**: Too aggressive loses information

### For Compaction Summaries

When the LLM compacts context, preserve:

- **Session state**: ID, active tasks, current phase
- **Recent actions**: What was just done and outcomes
- **Decisions**: Key choices and their rationale
- **Next steps**: Immediate actions and blockers
- **Context**: Essential background for the current task

### Anti-Patterns

Avoid these common mistakes:

| Anti-Pattern | Better Approach |
|--------------|-----------------|
| Loading entire files | Use snippets with context |
| Ignoring truncation notices | Check if full output needed |
| Disabling compaction | Tune thresholds instead |
| Repeating context | Trust what's in the summary |
| Worrying about limits | Let CWAM handle it |

---

## Integration Points

### Session Next

CWAM guidance is injected into continuation prompts:

```python
if reminders_enabled:
    cwam_rules = get_rules_for_context("context_window")
    if cwam_rules:
        prompt += f"\nCWAM: {cwam_rules[0]['guidance'].splitlines()[0]}"
```

### Rules Injection

CWAM rules are injected via the rules engine:

```bash
edison rules inject --state compaction --json
```

### Evidence Capture

Long outputs are truncated in evidence files:

```bash
edison evidence capture <task-id> --only test
# Output truncated if exceeding maxChars
```

---

## See Also

- [CONTINUATION.md](CONTINUATION.md) - FC/RL continuation system
- [OPENCODE_INTEGRATION.md](OPENCODE_INTEGRATION.md) - OpenCode plugin setup
- [CONFIGURATION.md](CONFIGURATION.md) - Full configuration guide
- [WORKFLOWS.md](WORKFLOWS.md) - Session workflow reference

---

**Last Updated:** 2026-01-06
**Version:** 2.0.0

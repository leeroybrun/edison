/**
 * Edison OpenCode plugin (generated).
 *
 * Generated by: `edison opencode setup`
 *
 * Edison is the source of truth for:
 *   - Completion/continuation: `edison session next --json --completion-only`
 *   - Rules applicability:
 *       - Task lifecycle: `edison rules inject --state <state> --format json`
 *       - Context guidance: `edison rules inject --context <context> --format json`
 *   - Execution config: `edison config show execution --json`
 *
 * This plugin implements:
 *   - FC (soft mode): single continuation injection on idle
 *   - RL (hard mode): repeated injection with budgets/cooldowns until complete
 *   - Tool output truncation (configurable, preserves headers)
 *   - Preemptive compaction (threshold-based, before hitting limits)
 *   - Token-limit recovery (detect errors, auto-compact, continue)
 *   - Non-interactive environment guardrails (env injection, banned command warnings)
 */

// -----------------------------------------------------------------------------
// Types
// -----------------------------------------------------------------------------

type EdisonSessionNext = {
  sessionId?: string;
  completion?: { isComplete?: boolean };
  continuation?: {
    shouldContinue?: boolean;
    prompt?: string;
    mode?: "soft" | "hard"; // FC (soft) or RL (hard)
  };
};

type EdisonRulesInject = {
  sessionId?: string;
  taskId?: string;
  contexts?: string[];
  rules?: { id: string; title: string; content: string; priority: string }[];
  injection?: string;
};

type EdisonSessionContext = {
  sessionId?: string;
  currentTaskState?: string;
};

/** Non-interactive execution configuration from Edison. */
type EdisonNonInteractiveConfig = {
  enabled?: boolean;
  env?: Record<string, string>;
  bannedCommandPatterns?: string[];
  onMatch?: "warn" | "block";
};

/** RL (Ralph Loop) state for iteration tracking per OpenCode session. */
type RLState = {
  iteration: number;
  lastInjectedAt: number;
  injectedOnce: boolean; // For soft mode: only inject once
  errors: number;
};

/** Compaction state for tracking context window usage per session. */
type CompactionState = {
  lastCompactionAt: number;
  lastPromptAt: number;
  recoveryAttempts: number;
  estimatedTokenUsage: number; // Heuristic: chars / 4
};

// -----------------------------------------------------------------------------
// Configuration (from Edison config or sensible defaults)
// -----------------------------------------------------------------------------

const RL_CONFIG = {
  maxIterations: 10, // Budget: stop after this many iterations
  cooldownSeconds: 5, // Minimum seconds between injections
  stopOnBlocked: true, // Stop if Edison reports blocked/no actionable step
};

const TRUNCATION_CONFIG = {
  enabled: true,
  maxChars: 50000, // Truncate outputs exceeding this
  preserveHeaderLines: 10, // Keep first N lines as headers
  truncationNotice: "\n\n[... output truncated by Edison plugin ...]\n",
};

const COMPACTION_CONFIG = {
  // Preemptive compaction settings (Edison-triggered)
  preemptive: {
    enabled: true,
    threshold: 0.70, // Compact at 70% of estimated limit
    cooldownSeconds: 120, // Minimum seconds between preemptive compactions
    // Estimated context limit in tokens (configurable per model)
    estimatedTokenLimit: 100000,
  },
  // Recovery compaction settings (Edison-triggered on errors)
  recovery: {
    enabled: true,
    maxAttempts: 3,
    // Error patterns to detect token-limit errors (provider-specific)
    errorPatterns: [
      /context.length/i,
      /token.*limit/i,
      /context.*too.*long/i,
      /max.*tokens/i,
      /context.*window/i,
      /rate.*limit.*tokens/i,
    ],
  },
  // Compaction hooks settings (OpenCode-triggered)
  // These capture ALL compaction events (user, auto, API-triggered)
  hooks: {
    // experimental.session.compacting: inject guidance before compaction
    compactingEnabled: true,
    // session.compacted event: inject context after compaction
    compactedEnabled: true,
  },
};

// -----------------------------------------------------------------------------
// State (ephemeral, per OpenCode session)
// -----------------------------------------------------------------------------

const rlStateMap = new Map<string, RLState>();
const compactionStateMap = new Map<string, CompactionState>();

function getRLState(sessionId: string): RLState {
  if (!rlStateMap.has(sessionId)) {
    rlStateMap.set(sessionId, {
      iteration: 0,
      lastInjectedAt: 0,
      injectedOnce: false,
      errors: 0,
    });
  }
  return rlStateMap.get(sessionId)!;
}

function getCompactionState(sessionId: string): CompactionState {
  if (!compactionStateMap.has(sessionId)) {
    compactionStateMap.set(sessionId, {
      lastCompactionAt: 0,
      lastPromptAt: 0,
      recoveryAttempts: 0,
      estimatedTokenUsage: 0,
    });
  }
  return compactionStateMap.get(sessionId)!;
}

// -----------------------------------------------------------------------------
// Edison Session ID Resolution
// -----------------------------------------------------------------------------

const EDISON_CLI_TIMEOUT_MS = 5_000;

async function execEdisonText(
  args: string[],
  timeoutMs: number = EDISON_CLI_TIMEOUT_MS,
): Promise<string | null> {
  try {
    const proc = Bun.spawn(["edison", ...args], {
      stdout: "pipe",
      stderr: "pipe",
    });

    let timer: ReturnType<typeof setTimeout> | null = null;
    const timeoutPromise = new Promise<never>((_, reject) => {
      timer = setTimeout(() => {
        try {
          proc.kill();
        } catch {
          // ignore
        }
        reject(new Error("timeout"));
      }, timeoutMs);
    });

    const [stdoutText, _stderrText, exitCode] = await Promise.race([
      Promise.all([
        new Response(proc.stdout).text(),
        new Response(proc.stderr).text(),
        proc.exited,
      ]),
      timeoutPromise,
    ]);

    if (timer) {
      clearTimeout(timer);
    }

    if (exitCode !== 0) {
      return null;
    }

    const trimmed = stdoutText.trim();
    return trimmed ? trimmed : null;
  } catch {
    return null;
  }
}

async function execEdisonJson<T>(
  args: string[],
  timeoutMs: number = EDISON_CLI_TIMEOUT_MS,
): Promise<T | null> {
  const out = await execEdisonText(args, timeoutMs);
  if (!out) {
    return null;
  }
  try {
    return JSON.parse(out) as T;
  } catch {
    return null;
  }
}

/**
 * Resolve Edison session ID using priority order:
 * 1. AGENTS_SESSION environment variable
 * 2. edison session context --json (sessionId field)
 * 3. Return null if not found (fail-open)
 */
async function resolveEdisonSessionId(): Promise<string | null> {
  // Priority 1: Environment variable
  const envSession = process.env.AGENTS_SESSION;
  if (envSession) {
    return envSession;
  }

  // Priority 2: Session context
  try {
    const data = await execEdisonJson<EdisonSessionContext>([
      "session",
      "context",
      "--json",
    ]);
    if (data?.sessionId) {
      return data.sessionId;
    }
  } catch {
    // Fail-open: continue without session
  }

  return null;
}

// -----------------------------------------------------------------------------
// Edison API Calls
// -----------------------------------------------------------------------------

async function fetchEdisonSessionNext(
  sessionId?: string,
): Promise<EdisonSessionNext | null> {
  const args = ["session", "next", "--json", "--completion-only"];
  if (sessionId) {
    args.push(sessionId);
  }
  return execEdisonJson<EdisonSessionNext>(args);
}

async function fetchEdisonRulesInjectForState(
  state: string,
): Promise<EdisonRulesInject | null> {
  // Use --state flag: Edison centralizes state-to-transition mapping
  return execEdisonJson<EdisonRulesInject>([
    "rules",
    "inject",
    "--state",
    state,
    "--format",
    "json",
  ]);
}

async function fetchEdisonRulesInjectForContext(
  context: string,
): Promise<EdisonRulesInject | null> {
  return execEdisonJson<EdisonRulesInject>([
    "rules",
    "inject",
    "--context",
    context,
    "--format",
    "json",
  ]);
}

async function fetchContextWindowRuleContext(): Promise<string> {
  try {
    const data = await execEdisonJson<any>([
      "config",
      "show",
      "context_window",
      "--json",
    ]);
    const ruleContext = data?.context_window?.prompts?.ruleContext;
    if (typeof ruleContext === "string" && ruleContext.trim()) {
      return ruleContext.trim();
    }
  } catch {
    // Fail-open
  }
  return "context_window";
}

async function getCurrentTaskState(): Promise<string | null> {
  try {
    const data = await execEdisonJson<EdisonSessionContext>([
      "session",
      "context",
      "--json",
    ]);
    return data?.currentTaskState || null;
  } catch {
    return null;
  }
}

/**
 * Fetch non-interactive execution config from Edison.
 * Returns config with sensible defaults if Edison is unavailable.
 */
async function fetchNonInteractiveConfig(): Promise<EdisonNonInteractiveConfig> {
  try {
    const data = await execEdisonJson<any>(["config", "show", "execution", "--json"]);
    if (!data) {
      throw new Error("missing execution config");
    }
    // `edison config show execution --json` returns `{ "execution": { ... } }`.
    // Fail-open for older/alternate shapes by falling back to `data` directly.
    const execution = data?.execution ?? data;
    const nonInteractive = execution?.nonInteractive || {};
    return {
      enabled: Boolean(nonInteractive.enabled),
      env: nonInteractive.env || {},
      bannedCommandPatterns: nonInteractive.bannedCommandPatterns || [],
      onMatch: nonInteractive.onMatch === "block" ? "block" : "warn",
    };
  } catch {
    // Fail-open: return disabled config
    return {
      enabled: false,
      env: {},
      bannedCommandPatterns: [],
      onMatch: "warn",
    };
  }
}

/**
 * Check if a command matches any banned pattern.
 * Patterns starting with ^ are treated as regex, others as substrings.
 */
function isCommandBanned(
  config: EdisonNonInteractiveConfig,
  command: string,
): { banned: boolean; pattern?: string } {
  if (!config.enabled || !command) {
    return { banned: false };
  }

  const patterns = config.bannedCommandPatterns || [];
  for (const pattern of patterns) {
    if (!pattern) continue;
    try {
      if (pattern.startsWith("^")) {
        // Regex pattern
        const regex = new RegExp(pattern);
        if (regex.test(command)) {
          return { banned: true, pattern };
        }
      } else {
        // Substring pattern
        if (command.includes(pattern)) {
          return { banned: true, pattern };
        }
      }
    } catch {
      // Invalid pattern, skip
    }
  }
  return { banned: false };
}

// -----------------------------------------------------------------------------
// Tool Output Truncation (CWAM)
// -----------------------------------------------------------------------------

/**
 * Truncate tool output if it exceeds maxChars, preserving header lines.
 * Fail-open: returns original output if anything goes wrong.
 */
function truncateToolOutput(output: string): string {
  if (!TRUNCATION_CONFIG.enabled) {
    return output;
  }

  try {
    if (output.length <= TRUNCATION_CONFIG.maxChars) {
      return output;
    }

    const lines = output.split("\n");
    const headerLines = lines.slice(0, TRUNCATION_CONFIG.preserveHeaderLines);
    const headerText = headerLines.join("\n");

    // Calculate remaining budget after headers
    const remainingBudget = TRUNCATION_CONFIG.maxChars - headerText.length;
    if (remainingBudget <= 0) {
      // Headers alone exceed budget; just truncate headers
      return headerText.slice(0, TRUNCATION_CONFIG.maxChars) +
        TRUNCATION_CONFIG.truncationNotice;
    }

    // Find how much of the remaining content we can include
    const remainingLines = lines.slice(TRUNCATION_CONFIG.preserveHeaderLines);
    const remainingText = remainingLines.join("\n");

    if (remainingText.length <= remainingBudget) {
      // No truncation needed after all
      return output;
    }

    // Truncate remaining text
    const truncatedRemaining = remainingText.slice(0, remainingBudget);
    return headerText + "\n" + truncatedRemaining + TRUNCATION_CONFIG.truncationNotice;
  } catch {
    // Fail-open: return original
    return output;
  }
}

// -----------------------------------------------------------------------------
// RL/FC Enforcement Logic
// -----------------------------------------------------------------------------

/**
 * Check if we should inject continuation based on mode and state.
 * - soft mode: inject only once per session
 * - hard mode: inject repeatedly until complete or budget exhausted
 */
function shouldInjectContinuation(
  rlState: RLState,
  mode: "soft" | "hard",
): { shouldInject: boolean; reason?: string } {
  const now = Date.now();

  // Soft mode (FC): only inject once
  if (mode === "soft") {
    if (rlState.injectedOnce) {
      return { shouldInject: false, reason: "soft mode: already injected once" };
    }
    return { shouldInject: true };
  }

  // Hard mode (RL): check budgets and cooldowns
  if (rlState.iteration >= RL_CONFIG.maxIterations) {
    return { shouldInject: false, reason: `maxIterations (${RL_CONFIG.maxIterations}) exhausted` };
  }

  const cooldownMs = RL_CONFIG.cooldownSeconds * 1000;
  const timeSinceLastInjection = now - rlState.lastInjectedAt;
  if (rlState.lastInjectedAt > 0 && timeSinceLastInjection < cooldownMs) {
    return {
      shouldInject: false,
      reason: `cooldown: ${Math.ceil((cooldownMs - timeSinceLastInjection) / 1000)}s remaining`,
    };
  }

  return { shouldInject: true };
}

// -----------------------------------------------------------------------------
// Compaction Logic (CWAM - Context Window Anxiety Management)
// -----------------------------------------------------------------------------

/**
 * Check if error matches token-limit error patterns.
 * Returns true if the error appears to be a context/token limit error.
 */
function isTokenLimitError(errorMessage: string): boolean {
  if (!COMPACTION_CONFIG.recovery.enabled) {
    return false;
  }
  return COMPACTION_CONFIG.recovery.errorPatterns.some((pattern) =>
    pattern.test(errorMessage)
  );
}

/**
 * Check if preemptive compaction should be triggered.
 * Uses estimated token usage vs configured threshold.
 */
function shouldTriggerPreemptiveCompaction(
  compactionState: CompactionState,
): { shouldCompact: boolean; reason?: string } {
  if (!COMPACTION_CONFIG.preemptive.enabled) {
    return { shouldCompact: false, reason: "preemptive compaction disabled" };
  }

  const now = Date.now();
  const cooldownMs = COMPACTION_CONFIG.preemptive.cooldownSeconds * 1000;

  // Check cooldown
  if (
    compactionState.lastCompactionAt > 0 &&
    now - compactionState.lastCompactionAt < cooldownMs
  ) {
    return {
      shouldCompact: false,
      reason: `cooldown: ${Math.ceil((cooldownMs - (now - compactionState.lastCompactionAt)) / 1000)}s remaining`,
    };
  }

  // Check usage threshold
  const usageRatio =
    compactionState.estimatedTokenUsage /
    COMPACTION_CONFIG.preemptive.estimatedTokenLimit;
  if (usageRatio >= COMPACTION_CONFIG.preemptive.threshold) {
    return {
      shouldCompact: true,
      reason: `usage ${Math.round(usageRatio * 100)}% >= threshold ${Math.round(COMPACTION_CONFIG.preemptive.threshold * 100)}%`,
    };
  }

  return { shouldCompact: false };
}

/**
 * Perform compaction and inject Edison session context afterward.
 * Uses official OpenCode session.compact API.
 * Returns true if compaction was successful.
 */
async function performCompaction(
  client: any,
  sessionId: string,
  compactionState: CompactionState,
): Promise<boolean> {
  try {
    // Call official OpenCode compact API
    await client.session.compact();

    // Update compaction state
    compactionState.lastCompactionAt = Date.now();
    compactionState.estimatedTokenUsage = 0; // Reset after compaction
    compactionState.recoveryAttempts = 0;

    // Inject Edison session context after compaction for recovery
    // This provides the LLM with session state after context is cleared
    const contextOutput = await fetchEdisonSessionContext();
    if (contextOutput) {
      await client.tui.appendPrompt({
        body: { text: `\n${contextOutput}\n` },
      });
    }

    return true;
  } catch {
    // Fail-open: compaction failed but don't crash
    return false;
  }
}

/**
 * Fetch Edison session context for injection after compaction.
 */
async function fetchEdisonSessionContext(): Promise<string | null> {
  return execEdisonText(["session", "context"]);
}

/**
 * Update estimated token usage based on prompt/response length.
 * Simple heuristic: ~4 chars per token.
 */
function updateTokenUsage(
  compactionState: CompactionState,
  textLength: number,
): void {
  // Heuristic: 4 chars ≈ 1 token
  const estimatedTokens = Math.ceil(textLength / 4);
  compactionState.estimatedTokenUsage += estimatedTokens;
}

// -----------------------------------------------------------------------------
// Plugin Export
// -----------------------------------------------------------------------------

export const Edison = async ({ client }: { client: any }) => {
  // Resolve session ID once at plugin init
  const edisonSessionId = await resolveEdisonSessionId();

  // Fetch non-interactive config from Edison at init
  const nonInteractiveConfig = await fetchNonInteractiveConfig();

  return {
    // Handle session events (idle, error)
    event: async ({
      event,
    }: {
      event: { type: string; sessionId?: string; error?: string; message?: string };
    }) => {
      const openCodeSessionId = event.sessionId || "default";

      // Cleanup ephemeral state on session end/close to avoid leaks.
      if (event.type === "session.end" || event.type === "session.closed") {
        rlStateMap.delete(openCodeSessionId);
        compactionStateMap.delete(openCodeSessionId);
        return;
      }

      const compactionState = getCompactionState(openCodeSessionId);

      // Handle session.error for token-limit recovery
      if (event.type === "session.error") {
        const errorMessage = event.error || event.message || "";

        // Check if this is a token-limit error
        if (isTokenLimitError(errorMessage)) {
          // Check recovery attempts
          if (
            compactionState.recoveryAttempts >= COMPACTION_CONFIG.recovery.maxAttempts
          ) {
            // Max recovery attempts reached, fail-open
            return;
          }

          // Increment recovery attempts and trigger compaction
          compactionState.recoveryAttempts += 1;
          await performCompaction(client, openCodeSessionId, compactionState);
        }
        return;
      }

      // Handle session.compacted for post-compaction context injection
      // This captures ALL compaction events (user-initiated, auto, API-triggered)
      if (event.type === "session.compacted") {
        if (!COMPACTION_CONFIG.hooks.compactedEnabled) {
          return; // Hooks disabled
        }
        // Re-inject Edison session context after any compaction
        // This helps the LLM recover state after context is cleared
        try {
          const contextOutput = await fetchEdisonSessionContext();
          if (contextOutput) {
            await client.session.prompt({
              noReply: true,
              text: contextOutput,
            });
          }
        } catch {
          // Fail-open: if Edison is missing or fails, continue silently
        }
        return;
      }

      // Handle session.idle for continuation injection
      if (event.type !== "session.idle") return;

      const rlState = getRLState(openCodeSessionId);

      // Check for preemptive compaction before processing
      const { shouldCompact } = shouldTriggerPreemptiveCompaction(compactionState);
      if (shouldCompact) {
        await performCompaction(client, openCodeSessionId, compactionState);
      }

      // Fetch continuation from Edison
      const payload = await fetchEdisonSessionNext(edisonSessionId || undefined);
      const shouldContinue = Boolean(payload?.continuation?.shouldContinue);
      const prompt = String(payload?.continuation?.prompt || "");
      const mode = payload?.continuation?.mode || "soft"; // Default to soft (FC)

      if (!shouldContinue || !prompt) {
        // Edison says complete or no actionable step
        if (RL_CONFIG.stopOnBlocked && rlState.iteration > 0) {
          // Clear state for next time
          rlStateMap.delete(openCodeSessionId);
          compactionStateMap.delete(openCodeSessionId);
        }
        return;
      }

      // Check if we should inject based on mode and state
      const { shouldInject, reason } = shouldInjectContinuation(rlState, mode);
      if (!shouldInject) {
        // Budget exhausted or cooldown active
        return;
      }

      // Get applicable rules for injection alongside continuation prompt
      // Edison handles state-to-transition mapping via --state flag
      let rulesInjection = "";
      const taskState = await getCurrentTaskState();
      if (taskState) {
        const rulesPayload = await fetchEdisonRulesInjectForState(taskState);
        if (rulesPayload?.injection) {
          rulesInjection = rulesPayload.injection;
        }
      }

      // Combine rules and continuation prompt
      // Rules first (context), then continuation prompt (action)
      const fullPrompt = rulesInjection
        ? `${rulesInjection}\n\n${prompt}`
        : prompt;

      // Update RL state
      rlState.iteration += 1;
      rlState.lastInjectedAt = Date.now();
      if (mode === "soft") {
        rlState.injectedOnce = true;
      }

      // Update token usage estimate
      updateTokenUsage(compactionState, fullPrompt.length);

      // Inject the continuation prompt
      await client.tui.appendPrompt({ body: { text: `${fullPrompt}\n` } });
    },

    // Handle tool.execute.before for non-interactive environment injection
    // Injects env vars and warns on banned commands (fail-open)
    toolExecuteBefore: async ({
      tool,
      args,
    }: {
      tool: string;
      args?: { command?: string; env?: Record<string, string> };
    }): Promise<{ args?: { command?: string; env?: Record<string, string> } }> => {
      // Only handle Bash tool
      if (tool !== "bash" && tool !== "Bash") {
        return { args };
      }

      // Skip if non-interactive not enabled
      if (!nonInteractiveConfig.enabled) {
        return { args };
      }

      const command = args?.command || "";

      // Check for banned commands
      const { banned, pattern } = isCommandBanned(nonInteractiveConfig, command);
      const mergedEnv = {
        ...(args?.env || {}),
        ...nonInteractiveConfig.env,
      };

      if (banned) {
        const cmdPreview = command.length > 300 ? `${command.slice(0, 300)}…` : command;
        const envKeys = Object.keys(nonInteractiveConfig.env || {}).join(", ");
        const warningMessage = `[Edison] WARNING: Command may hang in non-interactive environment.
Command: ${cmdPreview}
Matched pattern: ${pattern}
Recommendations:
- Use non-interactive alternatives (e.g., 'cat' instead of 'less')
- Add non-interactive flags (--yes, --no-pager, --quiet)
- Environment hints (keys): ${envKeys}`;

        // Emit warning to user (fail-open) or block with a safe failure (fail-closed).
        console.warn(warningMessage);
        if (nonInteractiveConfig.onMatch === "block") {
          return {
            args: {
              ...args,
              env: mergedEnv,
              command: "printf '%s\\n' '[Edison] BLOCKED: command matches banned non-interactive pattern' >&2; exit 1",
            },
          };
        }
      }

      return {
        args: {
          ...args,
          env: mergedEnv,
        },
      };
    },

    // Handle tool.execute.after for output truncation and usage tracking
    toolExecuteAfter: async ({
      result,
      sessionId,
    }: {
      result: { output?: string };
      sessionId?: string;
    }): Promise<{ output?: string }> => {
      if (!result?.output) {
        return result;
      }

      // Update token usage estimate for tool output
      const openCodeSessionId = sessionId || "default";
      const compactionState = getCompactionState(openCodeSessionId);
      updateTokenUsage(compactionState, result.output.length);

      // Truncate if needed (fail-open)
      const truncatedOutput = truncateToolOutput(result.output);
      return { ...result, output: truncatedOutput };
    },

    // experimental.session.compacting hook (Task 079)
    // Inject Edison compaction guidance BEFORE any compaction runs
    // This captures ALL compaction events (user, auto, API-triggered)
    "experimental.session.compacting": async (
      _input: unknown,
      output: { context?: string[]; prompt?: string },
    ) => {
      if (!COMPACTION_CONFIG.hooks.compactingEnabled) {
        return; // Hooks disabled
      }

      // Inject Edison compaction guidance into the compaction prompt
      // This tells the LLM what to preserve during compaction
      try {
        // Fetch compaction summary-shape rules from Edison
        const ruleContext = await fetchContextWindowRuleContext();
        const rulesPayload = await fetchEdisonRulesInjectForContext(ruleContext);
        if (rulesPayload?.injection) {
          // Append Edison's compaction guidance to the context
          output.context = output.context || [];
          output.context.push(rulesPayload.injection);
        }
      } catch {
        // Fail-open: if Edison is missing or fails, continue without guidance
      }
    },
  };
};

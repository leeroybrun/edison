#!/usr/bin/env bash
# Edison Hook: {{ id }}
# Type: {{ type }}
# Description: {{ description }}

# Source shared guard and check execution scope
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "$SCRIPT_DIR/_edison_guard.sh" ]]; then
    # shellcheck source=_edison_guard.sh
    source "$SCRIPT_DIR/_edison_guard.sh"
    edison_hook_guard "{{ id }}" "{{ execution_scope }}"
fi

{% set mgmt_dir = global_config.get("project_management_dir") %}
SESSION_FILE="{{ mgmt_dir }}/.session-id"

echo "ðŸ‘‹ Edison Session Ending..."

# Cleanup operations
{% set cfg = config if config is defined else {} %}
SESSION_ID=$(cat "$SESSION_FILE" 2>/dev/null | head -1 || echo "")

_edison_audit_event() {
  # Fail-open: audit must never break hooks.
  local event="$1"
  shift || true
  edison audit event "$event" \
    --repo-root "$PWD" \
    --session "$SESSION_ID" \
    --field "hook_id={{ id }}" \
    --field "hook_type={{ type }}" \
    "$@" 2>/dev/null || true
}

_edison_audit_event "hook.session-cleanup.start"

{% if cfg.get("save_logs", False) %}
_edison_audit_event "hook.session-cleanup.save-logs.requested"
{% endif %}

{% if cfg.get("run_memory_pipeline", False) %}
_edison_audit_event "hook.session-cleanup.memory.run.requested" --field "event={{ cfg.get('memory_pipeline_event', 'session-end') }}"

# Best-effort memory persistence (structured session insights, optional indexing).
# Fail-open: hooks must never break normal workflows.
MEM_EVENT="{{ cfg.get('memory_pipeline_event', 'session-end') }}"
MEM_ARGS=(--event "$MEM_EVENT" --session "$SESSION_ID" --repo-root "$PWD")
{% if cfg.get("memory_best_effort", True) %}
MEM_ARGS+=(--best-effort)
{% endif %}
edison memory run "${MEM_ARGS[@]}" >/dev/null 2>&1 || true
{% endif %}

_edison_audit_event "hook.session-cleanup.end" --field "save_logs={{ cfg.get('save_logs', False) }}"

exit 0

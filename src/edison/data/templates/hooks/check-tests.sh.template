#!/usr/bin/env bash
# Edison Hook: {{ id }}
# Type: {{ type }}
# Description: {{ description }}
# Blocking: {{ "YES" if blocking else "NO" }} (warn-only)

# Source shared guard and check execution scope
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "$SCRIPT_DIR/_edison_guard.sh" ]]; then
    # shellcheck source=_edison_guard.sh
    source "$SCRIPT_DIR/_edison_guard.sh"
    edison_hook_guard "{{ id }}" "{{ execution_scope }}"
fi

# Parse input JSON (with timeout to prevent hanging)
INPUT=$(timeout 1 cat 2>/dev/null || echo '{}')
FILE_PATH=$(echo "$INPUT" | jq -r '.args.file_path // empty' 2>/dev/null || echo "")
if [[ -z "$FILE_PATH" ]]; then
  exit 0
fi

{% set cfg = config if config is defined else {} %}
{% set skip_test_files = cfg.get("skip_test_files", False) %}
{% set warn_if_missing = cfg.get("warn_if_missing", False) %}

{% if skip_test_files %}
# Skip obvious test files (stack-agnostic heuristic)
if echo "$FILE_PATH" | grep -qE '(^|/)(test|tests|spec|specs)(/|$)|(^|/)test[^/]*\\.|\\.(test|spec)\\.'; then
  exit 0
fi
{% endif %}

{% if warn_if_missing %}
# Best-effort heuristic: if a corresponding test file already exists, stay silent.
# This is intentionally technology-agnostic and only checks common naming patterns.
DIR_PATH=$(dirname "$FILE_PATH")
BASE_NAME=$(basename "$FILE_PATH")
STEM="${BASE_NAME%.*}"
if compgen -G "$DIR_PATH/${STEM}_test.*" >/dev/null; then exit 0; fi
if compgen -G "$DIR_PATH/test_${STEM}.*" >/dev/null; then exit 0; fi
if compgen -G "$DIR_PATH/${STEM}.test.*" >/dev/null; then exit 0; fi
if compgen -G "$DIR_PATH/${STEM}.spec.*" >/dev/null; then exit 0; fi

echo ""
echo "No test file found for: $FILE_PATH"
echo "   Ensure the change is covered by appropriate tests per your project's conventions."
echo "   Follow TDD: write failing test (RED) → minimal fix (GREEN) → cleanup (REFACTOR)."
echo ""
{% endif %}

exit 0

#!/usr/bin/env bash
# Edison Hook: {{ id }}
# Type: {{ type }}
# Description: {{ description }}

# Source shared guard and check execution scope
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "$SCRIPT_DIR/_edison_guard.sh" ]]; then
    # shellcheck source=_edison_guard.sh
    source "$SCRIPT_DIR/_edison_guard.sh"
    edison_hook_guard "{{ id }}" "{{ execution_scope }}"
fi

# Parse input JSON (with timeout to prevent hanging)
INPUT=$(timeout 1 cat 2>/dev/null || echo '{}')
TOOL_NAME=$(echo "$INPUT" | jq -r '.tool' 2>/dev/null || echo "")
FILE_PATH=$(echo "$INPUT" | jq -r '.args.file_path // ""' 2>/dev/null || echo "")

{% set cfg = config if config is defined else {} %}

# Only for Write/Edit
if [[ "$TOOL_NAME" != "Write" && "$TOOL_NAME" != "Edit" ]]; then
  exit 0
fi

# Check if file matches patterns using bash glob matching
SHOULD_FORMAT=false
{% set patterns = cfg.get("file_patterns", []) %}
case "$FILE_PATH" in
  {% for pattern in patterns %}{{ pattern }}|{% endfor %}*.___never_match___)
    SHOULD_FORMAT=true
    ;;
esac

if [[ "$SHOULD_FORMAT" != "true" ]]; then
  exit 0
fi

echo "ðŸŽ¨ Auto-formatting: $FILE_PATH"

# Run formatters
{% set tools = cfg.get("tools", []) %}
{% for tool in tools %}
if command -v {{ tool }} &> /dev/null; then
  {{ tool }} --write "$FILE_PATH" 2>&1 || true
fi
{% endfor %}

exit 0

#!/usr/bin/env bash
# Edison Hook: {{ id }}
# Type: {{ type }}
# Description: {{ description }}
# Blocking: NO (always exit 0)

# Source shared guard and check execution scope
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "$SCRIPT_DIR/_edison_guard.sh" ]]; then
    # shellcheck source=_edison_guard.sh
    source "$SCRIPT_DIR/_edison_guard.sh"
    edison_hook_guard "{{ id }}" "{{ execution_scope }}"
fi

# Parse input JSON (with timeout to prevent hanging)
INPUT=$(timeout 1 cat 2>/dev/null || echo '{}')
FILE_PATHS=$(echo "$INPUT" | jq -r '.file_paths // [] | .[]' 2>/dev/null || echo "")

# Check if any file matches our patterns using bash glob matching
{% set cfg = config if config is defined else {} %}
{% set patterns = cfg.get("file_patterns", []) %}
RELEVANT=false
for file in $FILE_PATHS; do
  case "$file" in
    {% for pattern in patterns %}{{ pattern }}|{% endfor %}*.___never_match___)
      RELEVANT=true
      break
      ;;
  esac
done

if [[ "$RELEVANT" != "true" ]]; then
  exit 0
fi

# Get current task state from session context (don't fail if no session)
TASK_STATE=$(edison session context --json 2>/dev/null | jq -r '.currentTaskState // empty' 2>/dev/null)
if [[ -z "$TASK_STATE" ]]; then
  exit 0  # No active task, nothing to inject
fi

# Use Edison's rules inject API with --state flag
# Edison centralizes state-to-transition mapping (single source of truth)
INJECTION=$(edison rules inject --state "$TASK_STATE" --format markdown 2>/dev/null || echo "")
if [[ -n "$INJECTION" ]]; then
  echo ""
  echo "$INJECTION"
  echo ""
fi

exit 0

#!/usr/bin/env bash
# Edison Hook: {{ id }}
# Type: {{ type }}
# Description: {{ description }}
# Blocking: NO (always exit 0)

# Fast check: Skip if no Edison session file exists
SESSION_FILE=".project/.session-id"
if [[ ! -f "$SESSION_FILE" ]]; then
  exit 0  # No Edison session, skip hook
fi

# Parse input JSON (with timeout to prevent hanging)
INPUT=$(timeout 1 cat 2>/dev/null || echo '{}')
FILE_PATHS=$(echo "$INPUT" | jq -r '.file_paths // [] | .[]' 2>/dev/null || echo "")

# Check if any file matches our patterns using bash glob matching
{% set cfg = config if config is defined else {} %}
{% set patterns = cfg.get("file_patterns", []) %}
RELEVANT=false
for file in $FILE_PATHS; do
  case "$file" in
    {% for pattern in patterns %}{{ pattern }}|{% endfor %}*.___never_match___)
      RELEVANT=true
      break
      ;;
  esac
done

if [[ "$RELEVANT" != "true" ]]; then
  exit 0
fi

# Get current task state (don't fail if no session)
TASK_STATE=$(edison task status --current --json 2>/dev/null | jq -r '.state' 2>/dev/null || echo "none")

# Inject rules for current state
{% set rules_by_state = cfg.get("rules_by_state", {}) %}
{% for state, rules in rules_by_state.items() %}
if [[ "$TASK_STATE" == "{{ state }}" ]]; then
  echo ""
  echo "## Edison Rules ({{ state }} state)"
  echo ""
  {% for rule in rules %}
  RULE_CONTENT=$(edison rules get {{ rule }} --brief 2>/dev/null || echo "")
  if [[ -n "$RULE_CONTENT" ]]; then
    echo "### {{ rule }}"
    echo "$RULE_CONTENT"
    echo ""
  fi
  {% endfor %}
fi
{% endfor %}

exit 0

#!/usr/bin/env bash
# Edison Hook: {{ id }}
# Type: {{ type }}
# Description: {{ description }}
# Blocking: {{ "YES" if blocking else "NO" }} (always exits 0)

# Source shared guard and check execution scope
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "$SCRIPT_DIR/_edison_guard.sh" ]]; then
    # shellcheck source=_edison_guard.sh
    source "$SCRIPT_DIR/_edison_guard.sh"
    edison_hook_guard "{{ id }}" "{{ execution_scope }}"
fi

# Parse input JSON (with timeout to prevent hanging)
INPUT=$(timeout 1 cat 2>/dev/null || echo '{}')
TOOL_NAME=$(echo "$INPUT" | jq -r '.tool // empty' 2>/dev/null || echo "")

{% set cfg = config if config is defined else {} %}
{% set only_for_states = cfg.get("only_for_states", []) %}

# Get current task state from session context
TASK_STATE=$(edison session context --json 2>/dev/null | jq -r '.currentTaskState // empty' 2>/dev/null)
if [[ -z "$TASK_STATE" ]]; then
  exit 0  # No active task
fi

# Only remind in configured states
SHOULD_REMIND=false
{% for state in only_for_states %}
if [[ "$TASK_STATE" == "{{ state }}" ]]; then
  SHOULD_REMIND=true
fi
{% endfor %}

if [[ "$SHOULD_REMIND" != "true" ]]; then
  exit 0
fi

# Get allowed operations for current state
ALLOWED_OPS=$(edison task allowed-operations --state "$TASK_STATE" 2>/dev/null || echo "")

if [[ -n "$ALLOWED_OPS" ]]; then
  echo ""
  echo "ℹ️  State Machine Reminder (current state: $TASK_STATE):"
  echo "$ALLOWED_OPS"
  echo ""
fi

exit 0

# Edison Core Commands Configuration
# Defines available commands for IDE slash command generation

commands:
  enabled: true
  # Default to repo-local platforms. Codex prompts are user-global by default
  # (`~/.codex/prompts`) and should be opt-in at the project layer.
  platforms: [claude, cursor]

  # Selection strategy
  selection:
    mode: "domains"  # all | domains | explicit
    domains:
      - session
      - task
      - qa
      - rules
    exclude:
      - setup
      - internal
      - migrate

  # Platform configurations
  platform_config:
    claude:
      enabled: true
      output_dir: ".claude/commands"
      prefix: "edison."
      max_short_desc: 80
      template: "claude-command.md.template"
      # Default to workflow guidance prompts (no implicit execution).
      # Projects can re-enable if they want executable `!` snippets.
      allow_bash: false

    cursor:
      enabled: true
      output_dir: ".cursor/commands"
      prefix: "edison."
      max_short_desc: 120
      template: "cursor-command.md.template"
      allow_bash: true

    codex:
      enabled: true
      output_dir: "~/.codex/prompts"  # User directory
      prefix: "edison."
      max_short_desc: 100
      template: "codex-prompt.md.template"
      warn_user_scope: true

  # Core command definitions
  definitions:
    # Session management
    - id: session-next
      domain: session
      command: next
      short_desc: "Show next session steps"
      full_desc: |
        Workflow: compute next steps for the current session.

        Use this whenever you are unsure what Edison expects next. It reads
        session/task/QA state and returns the recommended next actions.
      cli: "edison session next <session_id>"
      args:
        - name: session_id
          description: "Session identifier (e.g., sess-001). If unknown, run `edison session status` first."
          required: true
      when_to_use: |
        - You just finished a step and want the next step
        - You're resuming work after a break
        - You suspect you're blocked by a guard/state mismatch
      related_commands:
        - session-status
        - task-status

    - id: session-status
      domain: session
      command: status
      short_desc: "Show current session state"
      full_desc: |
        Workflow: inspect current session state (tasks, worktree, validation state).
      cli: "edison session status"
      args: []
      when_to_use: "Anytime you need to check current session state"
      related_commands:
        - session-next
        - task-status

    - id: session-context
      domain: session
      command: context
      short_desc: "Print hook-safe session context"
      full_desc: |
        Prints a small, deterministic context refresher intended for:
        - Claude Code hooks (SessionStart/PreCompact/UserPromptSubmit)
        - Quick in-chat refresh without running full `session next`
      cli: "edison session context"
      args: []
      when_to_use: |
        - After context compaction
        - When you want a quick refresh without full orchestration output
      related_commands:
        - session-next
        - session-status

    - id: session-start
      domain: session
      command: start
      short_desc: "Start/resume: pick a START_* prompt (playbook)"
      full_desc: |
        Workflow: choose the correct START_* prompt based on what the user wants,
        then print the selected prompt text in-chat.

        Important:
        - Do NOT run `edison compose ...` from chat. Composition is a developer responsibility.
        - Prefer a minimal catalog: treat START_* as composable/extensible and discover them dynamically.
      cli: |
        edison list --type start --format detail
        edison read --type start START_<PROMPT_ID>
      args:
        - name: PROMPT_ID
          description: "Prompt ID suffix (e.g., NEW_SESSION, RESUME_SESSION, AUTO_NEXT)"
          required: true
      when_to_use: |
        - The user says “start a new session”, “resume”, “what next?”, “validate”, or “cleanup”
        - You need the canonical bootstrap instructions before acting
      related_commands:
        - session-status
        - session-context
        - session-next

    - id: read
      domain: rules
      command: read
      short_desc: "Read a composed artifact (playbook)"
      full_desc: |
        Workflow: read the canonical, composed artifact from `.edison/_generated/`.

        Notes:
        - This is for reading developer-composed artifacts (agents, constitutions, guidelines, start prompts).
        - Do NOT run `edison compose ...` from chat. If the file is missing, ask the developer to compose it.
      cli: "edison read <name> --type <type>"
      args:
        - name: type
          description: "Generated subfolder (e.g., constitutions, guidelines, agents, start). Empty means root."
          required: false
        - name: name
          description: "File name without extension (defaults to .md), e.g. ORCHESTRATOR, AVAILABLE_AGENTS"
          required: true
      when_to_use: |
        - The workflow tells you to read from `.edison/_generated/...`
        - You need the canonical, composed version (not a bundled template)
      related_commands:
        - rules-current

    - id: list
      domain: rules
      command: list
      short_desc: "List composed artifacts (playbook)"
      full_desc: |
        Workflow: list the canonical, composed artifacts under `.edison/_generated/`.

        Use `--type start` to discover available `START_*.md` prompts.
      cli: "edison list --type <type> --format detail"
      args:
        - name: type
          description: "Generated subfolder (e.g., start, constitutions, guidelines, agents). Empty means root."
          required: false
      when_to_use: |
        - You need to discover which composed files are available
        - You need to pick an appropriate start prompt / guideline / constitution
      related_commands:
        - read

    # Task management
    - id: task-new
      domain: task
      command: new
      short_desc: "Create a new task (playbook)"
      full_desc: |
        Workflow: create a new task with a stable ID and clear scope.

        Recommended:
        - Keep the task small enough to validate in one round.
        - Put acceptance criteria into the task description.
      cli: |
        edison task new --id <id> --slug <slug>
      args:
        - name: id
          description: "Numeric id (e.g., 100)"
          required: true
        - name: slug
          description: "Short slug (e.g., implement-auth)"
          required: true
      when_to_use: |
        - You're about to start a new unit of work
        - You want a canonical task record for Edison workflows
      related_commands:
        - task-claim
        - task-status

    - id: task-claim
      domain: task
      command: claim
      short_desc: "Claim and move task to wip"
      full_desc: |
        Workflow: move a task from `todo` → `wip` and associate it with the active session.

        After claiming:
        - Follow your agent constitution + mandatory workflow (TDD, no mocks, config-first).
        - Work only inside the session worktree (no git checkout/switch in primary).
      cli: "edison task claim <record_id>"
      args:
        - name: record_id
          description: "Task or QA identifier (e.g., 150-wave1-auth-gate)"
          required: true
      when_to_use: |
        - You are ready to start implementation on a specific task
        - You want Edison to lock/track ownership to prevent parallel edits
      related_commands:
        - task-status
        - session-next

    - id: task-status
      domain: task
      command: status
      short_desc: "Show current task state"
      full_desc: |
        Workflow: inspect a task's current state, owner, session linkage, and recent activity.
      cli: "edison task status <record_id>"
      args:
        - name: record_id
          description: "Task or QA identifier (e.g., 150-wave1-auth-gate)"
          required: true
      when_to_use: "To check current task progress and state"
      related_commands:
        - task-claim
        - session-status

    - id: task-ready
      domain: task
      command: ready
      short_desc: "Mark task ready for QA (wip→done)"
      full_desc: |
        Workflow: mark the task ready for validation (typically `wip` → `done`).

        Use this only when:
        - Tests are green
        - The implementation is complete (no TODO/FIXME placeholders)
        - Any required evidence generation has been run
      cli: "edison task ready <record_id>"
      args:
        - name: record_id
          description: "Task identifier to mark ready (omit to list ready tasks)"
          required: false
      when_to_use: |
        - Implementation is complete and ready to validate
      related_commands:
        - qa-new
        - qa-validate

    - id: task-blocked
      domain: task
      command: blocked
      short_desc: "Explain why a todo task is blocked"
      full_desc: |
        Lists todo tasks that are blocked by unmet `depends_on` prerequisites,
        and explains which dependency is blocking and its current state.
      cli: "edison task blocked"
      args: []
      when_to_use: |
        - You expected a task to show up in `task ready` but it doesn't
        - You want an explanation for dependency blocking
      related_commands:
        - task-ready
        - task-status

    # QA and validation
    - id: qa-new
      domain: qa
      command: new
      short_desc: "Create QA brief for a task"
      full_desc: |
        Workflow: create (or ensure) the QA brief/record for a completed task.

        Notes:
        - QA briefs track rounds, evidence, and validator results.
        - Create it when a task is moving toward validation.
      cli: "edison qa new <task_id>"
      args:
        - name: task_id
          description: "Task identifier"
          required: true
      when_to_use: |
        - The task is ready (or nearly ready) for validation
        - You want to start tracking validation rounds
      related_commands:
        - qa-validate
        - qa-round

    - id: validate-now
      domain: internal
      command: validate
      short_desc: "Validate current work (playbook)"
      full_desc: |
        Workflow: run the configured validators on the current context and record evidence.

        Use this to get fast feedback before marking a task as `done`, or as a
        final check before promotion.
      cli: "edison qa validate <task_id> --execute"
      args:
        - name: task_id
          description: "Task identifier to validate"
          required: true
      when_to_use: |
        - You want feedback while still implementing
        - You want a pre-flight validation run before task-ready
      related_commands:
        - session-next
        - task-status

    - id: qa-validate
      domain: qa
      command: validate
      short_desc: "Validate a specific task (playbook)"
      full_desc: |
        Workflow: run QA validation for a specific task (creates a validation round).
      cli: "edison qa validate <task_id> --execute"
      args:
        - name: task_id
          description: "Task identifier"
          required: true
      when_to_use: |
        - The task is `done` and ready for validation
        - You want Edison to run the validators (use `--execute`)
      related_commands:
        - qa-round
        - qa-promote

    - id: qa-audit
      domain: qa
      command: audit
      short_desc: "Audit prompt/guideline hygiene (duplication, purity)"
      full_desc: |
        Workflow: audit Edison prompt/guideline content for quality issues:
        - duplication across guidelines
        - purity violations (project terms leaking into core/packs)
      cli: "edison qa audit --check-duplication --check-purity"
      args: []
      when_to_use: |
        - You suspect duplicated/conflicting guidance across the composed stack
        - You want to enforce prompt best practices (single source of truth)
      related_commands:
        - rules-current

    - id: qa-round
      domain: qa
      command: round
      short_desc: "Inspect QA rounds for a task"
      full_desc: |
        Workflow: inspect the QA round history for a task (current round, list of rounds).
      cli: "edison qa round <task_id> --list"
      args:
        - name: task_id
          description: "Task identifier"
          required: true
      when_to_use: |
        - You want to see which round is current
        - You want to check whether QA is pending/blocked/approved
      related_commands:
        - qa-validate
        - task-status

    - id: qa-promote
      domain: qa
      command: promote
      short_desc: "Promote QA/task to validated"
      full_desc: |
        Workflow: promote a task/QA record to `validated` after successful validation.

        Only use when:
        - Required validators are green
        - Evidence is present for the round(s)
        - There are no open blocking findings
      cli: "edison qa promote <task_id>"
      args:
        - name: task_id
          description: "Task identifier"
          required: true
      when_to_use: |
        - All validations passed and you want to finalize
      related_commands:
        - qa-round
        - qa-audit

    # Rules and guidelines
    - id: rules-current
      domain: rules
      command: current
      short_desc: "Show rules for current state"
      full_desc: |
        Displays rules applicable to the current task state.
        Shows relevant guidelines, constraints, and best practices.
      cli: "edison rules check"
      args: []
      when_to_use: |
        - When starting a task to see applicable rules
        - When unsure about constraints
        - To refresh on current guidelines
      related_commands:
        - task-status

    - id: rules-tdd
      domain: rules
      command: get
      short_desc: "Show TDD workflow rules"
      full_desc: |
        Displays comprehensive TDD (Test-Driven Development) guidelines
        including RED-GREEN-REFACTOR workflow and best practices.
      cli: "edison rules show tdd"
      args: []
      when_to_use: "When implementing new features to follow TDD workflow"
      related_commands:
        - rules-current

    # Memory (optional)
    - id: memory-search
      domain: memory
      command: search
      short_desc: "Search long-term memory providers"
      full_desc: |
        Searches configured long-term memory providers (optional).
        By default, memory is disabled; enable providers in config to use.
      cli: "edison memory search <query>"
      args: []
      when_to_use: |
        - You want to recall why something was done
        - You want relevant historical context across sessions
      related_commands:
        - session-context

    - id: memory-save
      domain: memory
      command: save
      short_desc: "Save a memory summary"
      full_desc: |
        Saves a session summary string to configured memory providers (optional).
        Use this for ad-hoc notes; for structured session summaries use `memory run`.
      cli: "edison memory save <summary>"
      args: []
      when_to_use: |
        - You want to record a brief decision or gotcha
      related_commands:
        - memory-search
        - session-context

    - id: memory-run
      domain: memory
      command: run
      short_desc: "Run memory pipelines"
      full_desc: |
        Runs configured memory pipelines for an event (e.g. session-end).
        This is typically used to persist structured session insights and/or index episodic memory.
      cli: "edison memory run --event session-end --session <session-id>"
      args: []
      when_to_use: |
        - You want to persist structured session insights
        - You want to trigger provider indexing (episodic sync/index)
      related_commands:
        - memory-search
        - session-next

    # Helper commands
    - id: help
      domain: help
      command: help
      short_desc: "Show Edison help"
      full_desc: |
        Displays Edison Framework help and available commands.
        Shows command categories and usage information.
      cli: "edison --help"
      args: []
      when_to_use: "When exploring Edison capabilities"
      related_commands: []

    - id: status
      domain: status
      command: status
      short_desc: "Show complete status"
      full_desc: |
        Shows comprehensive status: session, task, worktree, and git state.
        One-command overview of everything relevant.
      cli: "edison session status && edison task list --status wip"
      args: []
      when_to_use: "Quick overview of current state"
      related_commands:
        - session-status
        - task-status

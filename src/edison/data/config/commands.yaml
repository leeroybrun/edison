# Edison Core Commands Configuration
# Defines available commands for IDE slash command generation

commands:
  enabled: true
  # Default to repo-local platforms. Codex prompts are user-global by default
  # (`~/.codex/prompts`) and should be opt-in at the project layer.
  platforms: [claude, cursor]

  # Selection strategy
  selection:
    mode: "domains"  # all | domains | explicit
    domains:
      - session
      - task
      - qa
      - rules
    exclude:
      - setup
      - internal
      - migrate

  # Platform configurations
  platform_config:
    claude:
      enabled: true
      output_dir: ".claude/commands"
      prefix: "edison."
      max_short_desc: 80
      template: "claude-command.md.template"
      # Default to workflow guidance prompts (no implicit execution).
      # Projects can re-enable if they want executable `!` snippets.
      allow_bash: false

    cursor:
      enabled: true
      output_dir: ".cursor/commands"
      prefix: "edison."
      max_short_desc: 120
      template: "cursor-command.md.template"
      allow_bash: true

    codex:
      enabled: true
      output_dir: "~/.codex/prompts"  # User directory
      prefix: "edison."
      max_short_desc: 100
      template: "codex-prompt.md.template"
      warn_user_scope: true

  # Core command definitions
  definitions:
    # Session management
    - id: session-next
      domain: session
      command: next
      short_desc: "Show next session steps"
      full_desc: |
        Workflow: compute next steps for the current session.

        Use this whenever you are unsure what Edison expects next. It reads
        session/task/QA state and returns the recommended next actions.
      cli: "edison session next <session_id>"
      args:
        - name: session_id
          description: "Session identifier (e.g., sess-001). If unknown, run `edison session status` first."
          required: true
      when_to_use: |
        - You just finished a step and want the next step
        - You're resuming work after a break
        - You suspect you're blocked by a guard/state mismatch
      related_commands:
        - session-status
        - task-status

    - id: session-status
      domain: session
      command: status
      short_desc: "Show current session state"
      full_desc: |
        Workflow: inspect current session state (tasks, worktree, validation state).
      cli: "edison session status"
      args: []
      when_to_use: "Anytime you need to check current session state"
      related_commands:
        - session-next
        - task-status

    - id: session-context
      domain: session
      command: context
      short_desc: "Print hook-safe session context"
      full_desc: |
        Prints a small, deterministic context refresher intended for:
        - Claude Code hooks (SessionStart/PreCompact/UserPromptSubmit)
        - Quick in-chat refresh without running full `session next`
      cli: "edison session context"
      args: []
      when_to_use: |
        - After context compaction
        - When you want a quick refresh without full orchestration output
      related_commands:
        - session-next
        - session-status

    - id: session-prompts
      domain: session
      command: prompts
      short_desc: "List available START_* prompts"
      full_desc: |
        Workflow: discover which START_* prompts exist for this repo (project-composed
        prompts take precedence over bundled prompts).
      cli: "edison session prompts"
      args: []
      when_to_use: |
        - You don't know which start prompt to use
        - You want to see all available START_* ids
      related_commands:
        - start-new-session
        - start-resume-session
        - start-auto-next

    # Session start prompts (bootstrap LLM sessions)
    - id: start-new-session
      domain: session
      command: start-new-session
      short_desc: "Print START_NEW_SESSION prompt"
      full_desc: |
        Prints the Edison START_NEW_SESSION prompt used to bootstrap a fresh session.
        This is a prompt document meant for the LLM; it does not mutate task/session state.
      cli: "edison compose all --start && cat .edison/_generated/start/START_NEW_SESSION.md"
      args: []
      when_to_use: |
        - Starting a brand new Edison session
        - You want the canonical start prompt text in-chat
      related_commands:
        - session-next
        - session-status

    - id: start-resume-session
      domain: session
      command: start-resume-session
      short_desc: "Print START_RESUME_SESSION prompt"
      full_desc: |
        Prints the Edison START_RESUME_SESSION prompt used to resume work in an existing session.
      cli: "edison compose all --start && cat .edison/_generated/start/START_RESUME_SESSION.md"
      args: []
      when_to_use: |
        - Resuming an existing session after a break
        - Re-establishing worktree confinement and current state
      related_commands:
        - session-next
        - session-status

    - id: start-auto-next
      domain: session
      command: start-auto-next
      short_desc: "Print START_AUTO_NEXT prompt"
      full_desc: |
        Prints the Edison START_AUTO_NEXT prompt used to automatically determine next actions.
      cli: "edison compose all --start && cat .edison/_generated/start/START_AUTO_NEXT.md"
      args: []
      when_to_use: |
        - You want Edison to recommend next steps based on current state
        - You are unsure what to do next and want the canonical prompt
      related_commands:
        - session-next

    - id: start-validate-session
      domain: start
      command: start-validate-session
      short_desc: "Print START_VALIDATE_SESSION prompt"
      full_desc: |
        Prints the Edison START_VALIDATE_SESSION prompt used to validate a session's readiness.
      cli: "edison compose all --start && cat .edison/_generated/start/START_VALIDATE_SESSION.md"
      args: []
      when_to_use: |
        - Before closing a session
        - When preparing for QA / validation workflow
      related_commands:
        - qa-validate
        - session-next

    - id: start-continue-stale
      domain: start
      command: start-continue-stale
      short_desc: "Print START_CONTINUE_STALE prompt"
      full_desc: |
        Prints the Edison START_CONTINUE_STALE prompt for continuing a stale/timed-out session.
      cli: "edison compose all --start && cat .edison/_generated/start/START_CONTINUE_STALE.md"
      args: []
      when_to_use: |
        - Recovering from a stale session state
        - You need canonical recovery instructions in-chat
      related_commands:
        - session-status

    - id: start-cleanup
      domain: start
      command: start-cleanup
      short_desc: "Print START_CLEANUP prompt"
      full_desc: |
        Prints the Edison START_CLEANUP prompt used for cleanup and hygiene workflows.
      cli: "edison compose all --start && cat .edison/_generated/start/START_CLEANUP.md"
      args: []
      when_to_use: |
        - End-of-session cleanup
        - Cleaning up worktrees or stale artifacts
      related_commands:
        - session-status

    # Task management
    - id: task-new
      domain: task
      command: new
      short_desc: "Create a new task (playbook)"
      full_desc: |
        Workflow: create a new task with a stable ID and clear scope.

        Recommended:
        - Keep the task small enough to validate in one round.
        - Put acceptance criteria into the task description.
      cli: |
        edison task new --id <id> --slug <slug>
      args:
        - name: id
          description: "Numeric id (e.g., 100)"
          required: true
        - name: slug
          description: "Short slug (e.g., implement-auth)"
          required: true
      when_to_use: |
        - You're about to start a new unit of work
        - You want a canonical task record for Edison workflows
      related_commands:
        - task-claim
        - task-status

    - id: task-claim
      domain: task
      command: claim
      short_desc: "Claim and move task to wip"
      full_desc: |
        Workflow: move a task from `todo` → `wip` and associate it with the active session.

        After claiming:
        - Follow your agent constitution + mandatory workflow (TDD, no mocks, config-first).
        - Work only inside the session worktree (no git checkout/switch in primary).
      cli: "edison task claim <record_id>"
      args:
        - name: record_id
          description: "Task or QA identifier (e.g., 150-wave1-auth-gate)"
          required: true
      when_to_use: |
        - You are ready to start implementation on a specific task
        - You want Edison to lock/track ownership to prevent parallel edits
      related_commands:
        - task-status
        - session-next

    - id: task-status
      domain: task
      command: status
      short_desc: "Show current task state"
      full_desc: |
        Workflow: inspect a task's current state, owner, session linkage, and recent activity.
      cli: "edison task status <record_id>"
      args:
        - name: record_id
          description: "Task or QA identifier (e.g., 150-wave1-auth-gate)"
          required: true
      when_to_use: "To check current task progress and state"
      related_commands:
        - task-claim
        - session-status

    - id: task-ready
      domain: task
      command: ready
      short_desc: "Mark task ready for QA (wip→done)"
      full_desc: |
        Workflow: mark the task ready for validation (typically `wip` → `done`).

        Use this only when:
        - Tests are green
        - The implementation is complete (no TODO/FIXME placeholders)
        - Any required evidence generation has been run
      cli: "edison task ready <record_id>"
      args:
        - name: record_id
          description: "Task identifier to mark ready (omit to list ready tasks)"
          required: false
      when_to_use: |
        - Implementation is complete and ready to validate
      related_commands:
        - qa-new
        - qa-validate

    - id: task-blocked
      domain: task
      command: blocked
      short_desc: "Explain why a todo task is blocked"
      full_desc: |
        Lists todo tasks that are blocked by unmet `depends_on` prerequisites,
        and explains which dependency is blocking and its current state.
      cli: "edison task blocked"
      args: []
      when_to_use: |
        - You expected a task to show up in `task ready` but it doesn't
        - You want an explanation for dependency blocking
      related_commands:
        - task-ready
        - task-status

    # QA and validation
    - id: qa-new
      domain: qa
      command: new
      short_desc: "Create QA brief for a task"
      full_desc: |
        Workflow: create (or ensure) the QA brief/record for a completed task.

        Notes:
        - QA briefs track rounds, evidence, and validator results.
        - Create it when a task is moving toward validation.
      cli: "edison qa new <task_id>"
      args:
        - name: task_id
          description: "Task identifier"
          required: true
      when_to_use: |
        - The task is ready (or nearly ready) for validation
        - You want to start tracking validation rounds
      related_commands:
        - qa-validate
        - qa-round

    - id: validate-now
      domain: internal
      command: validate
      short_desc: "Validate current work (playbook)"
      full_desc: |
        Workflow: run the configured validators on the current context and record evidence.

        Use this to get fast feedback before marking a task as `done`, or as a
        final check before promotion.
      cli: "edison qa validate <task_id> --execute"
      args:
        - name: task_id
          description: "Task identifier to validate"
          required: true
      when_to_use: |
        - You want feedback while still implementing
        - You want a pre-flight validation run before task-ready
      related_commands:
        - session-next
        - task-status

    - id: qa-validate
      domain: qa
      command: validate
      short_desc: "Validate a specific task (playbook)"
      full_desc: |
        Workflow: run QA validation for a specific task (creates a validation round).
      cli: "edison qa validate <task_id> --execute"
      args:
        - name: task_id
          description: "Task identifier"
          required: true
      when_to_use: |
        - The task is `done` and ready for validation
        - You want Edison to run the validators (use `--execute`)
      related_commands:
        - qa-round
        - qa-promote

    - id: qa-audit
      domain: qa
      command: audit
      short_desc: "Audit prompt/guideline hygiene (duplication, purity)"
      full_desc: |
        Workflow: audit Edison prompt/guideline content for quality issues:
        - duplication across guidelines
        - purity violations (project terms leaking into core/packs)
      cli: "edison qa audit --check-duplication --check-purity"
      args: []
      when_to_use: |
        - You suspect duplicated/conflicting guidance across the composed stack
        - You want to enforce prompt best practices (single source of truth)
      related_commands:
        - rules-current

    - id: qa-round
      domain: qa
      command: round
      short_desc: "Inspect QA rounds for a task"
      full_desc: |
        Workflow: inspect the QA round history for a task (current round, list of rounds).
      cli: "edison qa round <task_id> --list"
      args:
        - name: task_id
          description: "Task identifier"
          required: true
      when_to_use: |
        - You want to see which round is current
        - You want to check whether QA is pending/blocked/approved
      related_commands:
        - qa-validate
        - task-status

    - id: qa-promote
      domain: qa
      command: promote
      short_desc: "Promote QA/task to validated"
      full_desc: |
        Workflow: promote a task/QA record to `validated` after successful validation.

        Only use when:
        - Required validators are green
        - Evidence is present for the round(s)
        - There are no open blocking findings
      cli: "edison qa promote <task_id>"
      args:
        - name: task_id
          description: "Task identifier"
          required: true
      when_to_use: |
        - All validations passed and you want to finalize
      related_commands:
        - qa-round
        - qa-audit

    # Rules and guidelines
    - id: rules-current
      domain: rules
      command: current
      short_desc: "Show rules for current state"
      full_desc: |
        Displays rules applicable to the current task state.
        Shows relevant guidelines, constraints, and best practices.
      cli: "edison rules check"
      args: []
      when_to_use: |
        - When starting a task to see applicable rules
        - When unsure about constraints
        - To refresh on current guidelines
      related_commands:
        - task-status

    - id: rules-tdd
      domain: rules
      command: get
      short_desc: "Show TDD workflow rules"
      full_desc: |
        Displays comprehensive TDD (Test-Driven Development) guidelines
        including RED-GREEN-REFACTOR workflow and best practices.
      cli: "edison rules show tdd"
      args: []
      when_to_use: "When implementing new features to follow TDD workflow"
      related_commands:
        - rules-current

    # Memory (optional)
    - id: memory-search
      domain: memory
      command: search
      short_desc: "Search long-term memory providers"
      full_desc: |
        Searches configured long-term memory providers (optional).
        By default, memory is disabled; enable providers in config to use.
      cli: "edison memory search <query>"
      args: []
      when_to_use: |
        - You want to recall why something was done
        - You want relevant historical context across sessions
      related_commands:
        - session-context

    - id: memory-save
      domain: memory
      command: save
      short_desc: "Save a memory summary"
      full_desc: |
        Saves a session summary string to configured memory providers (optional).
        Use this for ad-hoc notes; for structured session summaries use `memory run`.
      cli: "edison memory save <summary>"
      args: []
      when_to_use: |
        - You want to record a brief decision or gotcha
      related_commands:
        - memory-search
        - session-context

    - id: memory-run
      domain: memory
      command: run
      short_desc: "Run memory pipelines"
      full_desc: |
        Runs configured memory pipelines for an event (e.g. session-end).
        This is typically used to persist structured session insights and/or index episodic memory.
      cli: "edison memory run --event session-end --session <session-id>"
      args: []
      when_to_use: |
        - You want to persist structured session insights
        - You want to trigger provider indexing (episodic sync/index)
      related_commands:
        - memory-search
        - session-next

    # Helper commands
    - id: help
      domain: help
      command: help
      short_desc: "Show Edison help"
      full_desc: |
        Displays Edison Framework help and available commands.
        Shows command categories and usage information.
      cli: "edison --help"
      args: []
      when_to_use: "When exploring Edison capabilities"
      related_commands: []

    - id: status
      domain: status
      command: status
      short_desc: "Show complete status"
      full_desc: |
        Shows comprehensive status: session, task, worktree, and git state.
        One-command overview of everything relevant.
      cli: "edison session status && edison task list --status wip"
      args: []
      when_to_use: "Quick overview of current state"
      related_commands:
        - session-status
        - task-status

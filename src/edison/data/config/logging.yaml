# Logging / Audit Configuration
#
# Edison logging is designed for project-scoped auditing with a single canonical
# audit JSONL stream. Events include `session_id`, `task_id`, and `invocation_id`
# fields (when available) for easy filtering.

logging:
  enabled: true

  audit:
    enabled: true
    # Canonical audit log (append-only, JSONL).
    # Filter by `session_id`, `task_id`, `invocation_id`, `event`, etc.
    path: "{PROJECT_MANAGEMENT_DIR}/logs/edison/audit.jsonl"
    # Sink-level enablement (allows keeping `audit.enabled: true` while disabling JSONL writes).
    jsonl:
      enabled: true

  invocation:
    # Optional: embed small stdout/stderr/python-log tails into the canonical audit log at
    # `cli.invocation.end` so consumers don't need to open per-invocation artifact files.
    embed_tails:
      enabled: false
      max_bytes: 20000

  stdio:
    capture:
      enabled: false
      paths:
        # These templates are expanded with runtime tokens (invocation_id, pid, timestamp).
        stdout: "{PROJECT_MANAGEMENT_DIR}/logs/edison/invocations/{invocation_id}.stdout.log"
        stderr: "{PROJECT_MANAGEMENT_DIR}/logs/edison/invocations/{invocation_id}.stderr.log"

  subprocess:
    enabled: true
    # Max bytes of stdout/stderr stored inline in audit events (truncate beyond this).
    max_output_bytes: 100000

  stdlib:
    enabled: false
    level: "INFO"
    # When enabled, Edison configures the Python stdlib `logging` module to write
    # to a per-invocation file (no stderr handler, so JSON output stays pure).
    path: "{PROJECT_MANAGEMENT_DIR}/logs/edison/invocations/{invocation_id}.python.log"

  redaction:
    enabled: false
    replacement: "[REDACTED]"
    patterns: []

  orchestrator:
    enabled: true
    capture_prompt: false
    max_prompt_bytes: 10000

  guards:
    enabled: true

  hooks:
    enabled: true

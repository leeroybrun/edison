"""
Edison session track command.

SUMMARY: Track implementation/validation work with heartbeats
"""
from __future__ import annotations

import argparse
import sys

from edison.cli import add_json_flag, add_repo_root_flag, OutputFormatter, get_repo_root

SUMMARY = "Track implementation/validation work with heartbeats"


def register_args(parser: argparse.ArgumentParser) -> None:
    """Register command-specific arguments."""
    subparsers = parser.add_subparsers(dest="subcommand", required=True)

    # start subcommand
    start_parser = subparsers.add_parser("start", help="Start tracking work")
    start_parser.add_argument("--task", required=True, help="Task ID")
    start_parser.add_argument(
        "--type",
        required=True,
        choices=["implementation", "validation"],
        help="Type of work being tracked"
    )
    start_parser.add_argument("--model", help="Execution backend/model identifier")
    start_parser.add_argument("--validator", help="Validator identifier (required for validation)")
    start_parser.add_argument("--round", type=int, help="Evidence round number (optional)")
    start_parser.add_argument(
        "--run-id",
        dest="run_id",
        help="Stable run UUID (optional; autogenerated when omitted)",
    )
    start_parser.add_argument(
        "--process-id",
        dest="process_id",
        type=int,
        help="OS PID to record (optional; defaults to current process)",
    )
    start_parser.add_argument(
        "--continuation-id",
        dest="continuation_id",
        help="Continuation/resume identifier (e.g., Codex/Pal continuation id)",
    )
    add_json_flag(start_parser)
    add_repo_root_flag(start_parser)

    # heartbeat subcommand
    heartbeat_parser = subparsers.add_parser("heartbeat", help="Send heartbeat")
    heartbeat_parser.add_argument("--task", required=True, help="Task ID")
    heartbeat_parser.add_argument("--validator", help="Validator identifier (optional)")
    heartbeat_parser.add_argument("--round", type=int, help="Evidence round number (optional)")
    heartbeat_parser.add_argument(
        "--run-id",
        dest="run_id",
        help="Run UUID (optional; when set, updates only matching records)",
    )
    heartbeat_parser.add_argument(
        "--process-id",
        dest="process_id",
        type=int,
        help="OS PID to record (optional; updates processId in tracking payloads)",
    )
    add_json_flag(heartbeat_parser)
    add_repo_root_flag(heartbeat_parser)

    # complete subcommand
    complete_parser = subparsers.add_parser("complete", help="Mark work as complete")
    complete_parser.add_argument("--task", required=True, help="Task ID")
    complete_parser.add_argument(
        "--validator",
        help="Validator identifier (when set, completes only that validator's tracking record)",
    )
    complete_parser.add_argument("--round", type=int, help="Evidence round number (optional)")
    complete_parser.add_argument(
        "--run-id",
        dest="run_id",
        help="Run UUID (optional; when set with --validator, must match the validator report's runId)",
    )
    complete_parser.add_argument(
        "--process-id",
        dest="process_id",
        type=int,
        help="OS PID to record (optional; updates processId in tracking payloads)",
    )
    complete_parser.add_argument(
        "--status",
        choices=["complete", "blocked", "partial"],
        default="complete",
        help="Implementation completion status (implementation only)",
    )
    add_json_flag(complete_parser)
    add_repo_root_flag(complete_parser)

    # active subcommand
    active_parser = subparsers.add_parser("active", help="List active tracking sessions")
    add_json_flag(active_parser)
    add_repo_root_flag(active_parser)

    # sweep subcommand
    sweep_parser = subparsers.add_parser(
        "sweep",
        help="Detect stopped processes and append stop events to the process log",
    )
    add_json_flag(sweep_parser)
    add_repo_root_flag(sweep_parser)

    # processes subcommand
    processes_parser = subparsers.add_parser(
        "processes",
        help="List tracked processes (computed from append-only process events JSONL)",
    )
    processes_parser.add_argument(
        "--all",
        action="store_true",
        help="Include stopped processes (default: active only)",
    )
    add_json_flag(processes_parser)
    add_repo_root_flag(processes_parser)


def main(args: argparse.Namespace) -> int:
    """Track session work - delegates to core tracking helpers."""
    formatter = OutputFormatter(json_mode=getattr(args, "json", False))

    try:
        repo_root = get_repo_root(args)
        from edison.core.qa.evidence import tracking

        if args.subcommand == "start":
            if args.type == "implementation":
                result = tracking.start_implementation(
                    str(args.task),
                    project_root=repo_root,
                    model=getattr(args, "model", None),
                    round_num=getattr(args, "round", None),
                    continuation_id=getattr(args, "continuation_id", None),
                    run_id=getattr(args, "run_id", None),
                    process_id=getattr(args, "process_id", None),
                )
                # Compute task start checklist for implementation work
                try:
                    from edison.core.workflow.checklists.task_start import TaskStartChecklistEngine
                    engine = TaskStartChecklistEngine()
                    checklist_result = engine.compute(
                        task_id=str(args.task),
                        session_id=result.get("sessionId"),
                    )
                    result["checklist"] = checklist_result.to_dict()
                except Exception:
                    # Fail-open: tracking must work even if checklist fails
                    pass
            else:
                if not getattr(args, "validator", None):
                    raise ValueError("--validator is required for type=validation")
                if not getattr(args, "model", None):
                    raise ValueError("--model is required for type=validation")
                result = tracking.start_validation(
                    str(args.task),
                    project_root=repo_root,
                    validator_id=str(args.validator),
                    model=str(args.model),
                    round_num=getattr(args, "round", None),
                    continuation_id=getattr(args, "continuation_id", None),
                    run_id=getattr(args, "run_id", None),
                    process_id=getattr(args, "process_id", None),
                )

            if formatter.json_mode:
                formatter.json_output(result)
            else:
                formatter.text(
                    f"Started {result['type']} tracking for {result['taskId']} (round {result['round']})"
                )
                # Show checklist items in human-readable format
                checklist = result.get("checklist", {})
                if checklist.get("items"):
                    formatter.text("\nTask Start Checklist:")
                    for item in checklist["items"]:
                        severity = item.get("severity", "info")
                        status = item.get("status", "unknown")
                        title = item.get("title", "Unknown")
                        icon = "!" if severity == "blocker" and status != "ok" else "-"
                        status_icon = "[OK]" if status == "ok" else f"[{status.upper()}]"
                        formatter.text(f"  {icon} {status_icon} {title}")
                        if item.get("suggestedCommands") and status != "ok":
                            for cmd in item["suggestedCommands"]:
                                formatter.text(f"      -> {cmd}")

        elif args.subcommand == "heartbeat":
            result = tracking.heartbeat(
                str(args.task),
                project_root=repo_root,
                validator_id=getattr(args, "validator", None),
                run_id=getattr(args, "run_id", None),
                round_num=getattr(args, "round", None),
                process_id=getattr(args, "process_id", None),
            )
            formatter.json_output(result) if formatter.json_mode else formatter.text(
                f"Heartbeat updated ({len(result['updated'])} file(s))"
            )

        elif args.subcommand == "complete":
            if getattr(args, "validator", None):
                result = tracking.complete_validation(
                    str(args.task),
                    project_root=repo_root,
                    validator_id=str(args.validator),
                    round_num=getattr(args, "round", None),
                    run_id=getattr(args, "run_id", None),
                    process_id=getattr(args, "process_id", None),
                )
                formatter.json_output(result) if formatter.json_mode else formatter.text(
                    f"Completed validator tracking for {result.get('validatorId')} (round {result.get('round')})"
                )
            else:
                result = tracking.complete(
                    str(args.task),
                    project_root=repo_root,
                    implementation_status=str(getattr(args, "status", "complete")),
                    run_id=getattr(args, "run_id", None),
                    process_id=getattr(args, "process_id", None),
                )
                formatter.json_output(result) if formatter.json_mode else formatter.text(
                    f"Completed tracking ({len(result['updated'])} file(s))"
                )

        elif args.subcommand == "active":
            active = tracking.list_active(project_root=repo_root)
            if formatter.json_mode:
                formatter.json_output({"active": active, "count": len(active)})
            else:
                if not active:
                    formatter.text("No active tracking sessions found")
                else:
                    for it in active:
                        kind = it.get("type")
                        task_id = it.get("taskId")
                        extra = f" ({it.get('validatorId')})" if it.get("validatorId") else ""
                        formatter.text(f"- {task_id}{extra}: {kind} (round {it.get('round')})")

        elif args.subcommand == "sweep":
            from edison.core.tracking import sweep_processes

            result = sweep_processes(repo_root=repo_root)
            formatter.json_output(result) if formatter.json_mode else formatter.text(
                f"Recorded stop events for {result.get('stoppedRecorded')} process(es)"
            )

        elif args.subcommand == "processes":
            from edison.core.tracking import list_processes

            active_only = not bool(getattr(args, "all", False))
            procs = list_processes(repo_root=repo_root, active_only=active_only)
            if formatter.json_mode:
                formatter.json_output({"processes": procs, "count": len(procs)})
            else:
                if not procs:
                    formatter.text("No tracked processes found")
                else:
                    for it in procs:
                        kind = it.get("kind") or "process"
                        pid = it.get("processId")
                        task = it.get("taskId")
                        sid = it.get("sessionId")
                        ref = f"task={task}" if task else f"session={sid}" if sid else "unscoped"
                        formatter.text(f"- {kind} pid={pid} {ref} state={it.get('state')}")

        return 0

    except Exception as e:
        formatter.error(e, error_code="error")
        return 1

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    register_args(parser)
    args = parser.parse_args()
    sys.exit(main(args))

We have migrated our "edison" Ai-project-management and AI-automated-software development from /Users/leeroy/Documents/Development/wilson-pre-edison/.agents into it's own repository in /Users/leeroy/Documents/Development/edison, with now ONLY the final generated/composed files for our wilson project (which should be generated when running the "edison" composition commands in the wilson-leadgen folder based on the config in /Users/leeroy/Documents/Development/wilson-leadgen/.edison/config and overlays in /Users/leeroy/Documents/Development/wilson-leadgen/.edison) in /Users/leeroy/Documents/Development/wilson-leadgen/.edison/_generated. 

It should also compose + generate the /Users/leeroy/Documents/Development/wilson-leadgen/.claude/CLAUDE.md, /Users/leeroy/Documents/Development/wilson-leadgen/.claude/settings.json, /Users/leeroy/Documents/Development/wilson-leadgen/.claude/agents, /Users/leeroy/Documents/Development/wilson-leadgen/.claude/commands, /Users/leeroy/Documents/Development/wilson-leadgen/.claude/hooks, /Users/leeroy/Documents/Development/wilson-leadgen/.cursor/commands, as well as the zen config & prompts with the enabled and composed subagents for this project (based on the .edison config + overlays + enabled packs overlays) in /Users/leeroy/Documents/Development/wilson-leadgen/.zen/conf/cli_clients/claude.json
/Users/leeroy/Documents/Development/wilson-leadgen/.zen/conf/cli_clients/codex.json
/Users/leeroy/Documents/Development/wilson-leadgen/.zen/conf/cli_clients/gemini.json
/Users/leeroy/Documents/Development/wilson-leadgen/.zen/conf/systemprompts

<context>
## The Edison Framework
**What it is**:
- An AI-automated software development framework
- Orchestrates multiple AI agents (Claude, Codex, Gemini) for specialized tasks
- Uses pack-based architecture for technology-specific knowledge (Next.js, React, Prisma, Tailwind)
- Enforces workflow via state machines (tasks: todo → wip → done, sessions: active → validated)
- Composes prompts from modular guidelines and generates outputs for different AI clients
**What it does**:
- Generates prompts for AI agents based on project context and changed files
- Auto-activates packs based on file patterns (e.g., `*.prisma` → activate Prisma pack)
- Validates work through multi-model AI validators (codex-global, claude-global, gemini-global)
- Manages sessions, tasks, and validation workflow with state machines
- Provides CLI tools for session management, task claiming, validation execution
- Repeat important rules (which are extracted from the guidelines and completely extensible/configurable) to the LLMs all along the way to make sure they remember them
**Why it matters**:
- Enables consistent, high-quality AI-assisted development across large teams
- Prevents AI agents from giving conflicting or context-free advice
- Enforces coding standards, testing patterns, and architectural decisions
- Makes AI agents "project-aware" (know your tech stack, patterns, constraints)

<edison_brief_and_vision>
We are working on implementing an AI-automated software development framwework using Ai-automated project management and review/qa named "Edison".

It was implemented in our "wilson" project, as this is an idea which started from the development process of this "wilson" project in /Users/leeroy/Documents/Development/wilson-pre-edison/.agents, but we wanted to extract the idea and concepts, and refine them further, to be have a fully project-agnostic core, with "packs" to augment/extend the core with technologies-specifics and then project specifics (core -> packs -> project).

The goal is to define tasks, and then have an orchestrator AI delegate these tasks in parallel for orchestration. Each session can use git worktree and is runned by 1 orchestrator and multiple specialized agents (implementers) and validators, which can be composable depending on the project using "packs". Specialized agents and validators can also be defined per-project. A rules system allow to define rules to follow for every step of the implementation/workflow, and a core set of guidelines are laded/enforced for every sessions/agents/validators, and can be extended/composed by the packs and the specific project. The workflow is enforced by a state machine and the use of CLI scripts and verifications, which instruct the orchestrator about next/current steps, and instruct the implementers/validators to execute CLIs as well to gather the rules/guidelines necessary for their task as well as updating the task documents and qa documents. If any agent/validator notice new issues or was not able to complete/finalize his work, he adds followups to his report that the orchestrator will then check against all the project's task to see if they already exists, and if not, will create new tasks. If the new tasks are related/necessary to the current tasks/session, he will link them to the current task and claim them in the current session. Linked tasks can also be used by the orchestrator to create multiple subtasks for a task and delegate their implementation to multiple parallel agents. The qa of linked/child tasks is performed when ALL the linked tasks are done, and the validators receive all the tasks documents and all the qa documents of all the linked tasks, to perform a comprehensive and complete validation/analysis. If any issue/followup arises from the validators, the related tasks are kept in "wip" and qa moved back to "blocked", and new linked tasks are created to apply all the fixes/followups needed before starting the validation again until everything is ready and complete. Rules are used to enforce and repeat important parts of the guidelines for each step of the process, to make sure neither the orchestrator or the agents/validators forgets them.

The goal is to have a fully composable architecture/process/workflow with:
- Guidelines
- RUles
- Agents (implementers)
- Validators

Each of these can be defined in the "core" and/or in "packs" and/or in the project. And each of those can be extended/composed down, so that rules/guidelines/agents/validators defined in the core can be extended/composed in packs level AND in the project level, and rules/guidelines/agents/validators defined in packscan be extended/composed in the project level.

We currently use Claude Code as orchestrator, but the orchestrator implementation should be Ai-agnostic, so we can use any AI as orchestrator, and simply give the AI a start prompt or commands to read all the documents necessary (guidelines) and start a new session.

We are using zen mcp to delegate work to sub-agent (agents and validators), and claude code subtasks (when orchestrator is claude and subtasks must be delegated to claude subagents) and have integrated the generation of composable zen prompts from our agents/validators and all our composable architecture, so that the end zen subagents in eaxh project are in fact our specialized agents/validators with core+packs+project instructions. We are doing the same for claude code agents, and plan to add any additional useful type of subagent prompt generation to the mix (if for example gemini start supporting subagents and subagents prompts, we could integrate it as well).

Edison should be folder-agnostic and reusable from any folder/project, as the goal is to be able to call our "edison" command from anx project and have it work from the project's .edison folder containing the edison's prject specifics (config, overlays, etc)

Until now the default edison folder in projects was named ".agents", but we have to rename it to ".edison" now. The goal is to have edison installed in the user's computer/PATH by uvx, and then simply calling for example "cd eilson-leadsgen && edison session next", etc (it should then work on the CURRENT folder from where is is called, so that we can "cd" into out "wilson-leadgen" for example and use "edison session ..." and all commands and it should work in the current folder and look for the current project's .edison folder for config/overlays/etc, and it should also work with worktrees for example, so that we can cd into a worktree and continue working on the worktree's session, and make sure that when we create a new edison session which creates a worktree, that all the other commands are then called from that worktree, including zen clink, claude, etc so that we are SURE that a session ONLY works from his worktree if the config is enabled.

TO use edison in a new project we could then "cd" into the project's folder and then call "edison setup" which would scafold the project's .edison folder (using an assistant if possible) and it will then automatically call our "compose" command and all commands necessary to generate our project's specific files/prompts/configs/agents/etc.
</edison_brief_and_vision>
</context>

We already performed multiple analyses to try to indentify any gaps/missing instructions/missing sections/missing rules/missing guidelines and any wrong/missing logic in our composition engine which i need you to read END-to-END (in multiple 1500 lines reads for example, if too big to read in 1 go):
/Users/leeroy/Documents/Development/edison/PHASE_PRE-EDISON_MIGRATION_1_DEEP_CONTENT_VALIDATION_AGENTS_ENTRY_POINT.md
/Users/leeroy/Documents/Development/edison/PHASE_PRE-EDISON_MIGRATION_1_NEW_ANALYSIS.md

PHASE_PRE-EDISON_MIGRATION_1_DEEP_CONTENT_VALIDATION_AGENTS_ENTRY_POINT is NOT authorative, and just additional context in case anything from it is relevant and missing from PHASE_PRE-EDISON_MIGRATION_1_NEW_ANALYSIS, as PHASE_PRE-EDISON_MIGRATION_1_NEW_ANALYSIS should be the canonical, authorative and complete analysis


please orchestrate, delegate and analyse a new completely fresh and independent deep analysis and comparison of our previous /Users/leeroy/Documents/Development/wilson-pre-edison/.agents files and folders against our new architecture and guidelines/agents/files in /Users/leeroy/Documents/Development/wilson-leadgen/.edison/_generated, and /Users/leeroy/Documents/Development/wilson-leadgen/.claude/CLAUDE.md, /Users/leeroy/Documents/Development/wilson-leadgen/.claude/settings.json, /Users/leeroy/Documents/Development/wilson-leadgen/.claude/agents, /Users/leeroy/Documents/Development/wilson-leadgen/.claude/commands, /Users/leeroy/Documents/Development/wilson-leadgen/.claude/hooks, /Users/leeroy/Documents/Development/wilson-leadgen/.cursor/commands, as well as the zen config & prompts with the enabled and composed subagents for this project (based on the .edison config + overlays + enabled packs overlays) in /Users/leeroy/Documents/Development/wilson-leadgen/.zen/conf/cli_clients/claude.json
/Users/leeroy/Documents/Development/wilson-leadgen/.zen/conf/cli_clients/codex.json
/Users/leeroy/Documents/Development/wilson-leadgen/.zen/conf/cli_clients/gemini.json
/Users/leeroy/Documents/Development/wilson-leadgen/.zen/conf/systemprompts, to find ANY additional gaps/mssing sections/missing instructions/missing logic/wrong logic, and ensuring we migrate EVERYTHING to the correct place (either the edison CORE or the edison PACKS or the project overlays) AND that the complete implementation is correct and corking exactly as described in the "context" above, includign regarding the constitutions, guidelines, etc. 

You MUST assign 2 subagent (1x codex using edison-zen mcp and 1x claude code opus using task tool) for each files in /Users/leeroy/Documents/Development/wilson-pre-edison/.agents/{agents|delegation|guidelines|rules|validators} and /Users/leeroy/Documents/Development/wilson-pre-edison/.agents/AGENTS.md /Users/leeroy/Documents/Development/wilson-pre-edison/.claude/CLAUDE.md /Users/leeroy/Documents/Development/wilson-pre-edison/.agents/START.SESSION.md which should perform the exact same analysis and report concise FACTS and issues/missing sections/instructions/files.

Then, based on the reports, compile every findings together and compare them against our current existing /Users/leeroy/Documents/Development/edison/PHASE_PRE-EDISON_MIGRATION_1_NEW_ANALYSIS.md and enhance/refine/complement this file (DONT REGENERTE A NEW ANALYSIS, but ENHANCE/REFINE/UPDATE/ADD TO THE EXISTING PHASE_PRE-EDISON_MIGRATION_1_NEW_ANALYSIS) so that we are ABSOLUTELY SURE that we missed NO file, NO instruction, NO rule, NO section and that our PHASE_PRE-EDISON_MIGRATION_1_NEW_ANALYSIS is as complete and detailled as possible with EVERYTHING that needs to be migrated/enhanced. Make sure to update the PHASE_PRE-EDISON_MIGRATION_1_NEW_ANALYSIS document after each wave of subagents have produced their report, and not wait for ALL subagents/waves to be finished, as you may be flooded with too many informations and might miss some of the reported issues/changes necessary

In addition, we should check and include ALL the changes necessary to make sure that:

- guidelines, rules, agents & validators can be defined either in the core and then extended both in packs AND/OR in the project. They can also be defined in packs (NOT in core) for technology specifics guidelines/agents/rules/validators and then extended in the project if necessary. OR even defined in the project directly for very project-specifics
- everything should be configurable and extensible, so NO hardcoded lists/sessings/values. For example, we shoul have NO hardcoded config values in our libs/scripts (ALL should liver in yml config files) AND ALSO ABSOLUTELY NO hardcoded lists of agents/validators/guidelines/rules in our files/prompts/guidelines, as these ARE dynamic and SHOULD BE dynamic
- the files that will be used then in our project will all be generated in the .edison/_generated folder, as well as .zen/.claude/.cursor/AGENTS.md/etc. we will and should NEVER link/redirect to the core files/prompts/guidelines/rules/agents/validators files in the edison core folder, as we are interested in the final prompts/guidelines/files generated with the packs + project specifics, as each file can be extended/composed down to the project-level
- We currently compose an "ORCHESTRATOR_GUIDE" in /Users/leeroy/Documents/Development/wilson-leadgen/.edison/_generated/ORCHESTRATOR_GUIDE.md and /Users/leeroy/Documents/Development/wilson-leadgen/.edison/_generated/orchestrator-manifest.json, which are not composable. We should replace that concept with "constitutions" instead, which should apply to both orchestrators but also agents and validators, by adding new CORE files/templates for these in our edison CORE that should be composable and extendable in packs AND in the project's .edison folder, and should generate a .edison/_generated/constitutions/{ORCHESTRATORS|AGENTS|VALIDATORS}.md files (no json needed)
- the "constitutions" for agents/orchestrators/validators should be made as a mandatory read in each agents/validators prompts
- for orchestrators, it will replace + merge the "manifest.json" and SESSION.START/AGENTS.md that the orchestrator needed to read in the pre-edison era AND the current (to be removed) ORCHESTRATOR_GUIDE
- the project's AGENTS.md file should be generated by our composition engine in the same fashion (base defined in core + extended in packs if relevant/necessary and at the project level). It should NOT include orchestration/agents specifics, as claude can be used as an agent/orchestrator/validator, and should ONLY have instructions relevant for all agents types (orchestrator/validator/agent).
- .claude/CLAUDE.md should be composed as well in the same fashion (base defined in core + extended in packs if relevant/necessary and at the projedt level) and the final .claude/CLAUDE.md file should be generated and maintained by our composition engine. It should NOT include orchestration/agents specifics, as claude can be used as an agent/orchestrator/validator, and should ONLY have instructions specific to claude and be the entrypoint linking to the project's AGENTS.md file
- ideally, constitutions for agents/orchestrators/validators should be extensible in the same way and have a base defined in the core + packs additions (if necessary) + project additions (if necessary)
- agents specifics (but common for all agents) will be maintained in guidelines/agents files in guidelines/agents and made as mantarory reads AND/OR in the agents constitution, and agents-specific guidelines will be made mandatory reads for agents, which will be automatically generated/linked in the constitution/AGENTS.md file. same for orchestrators and validators
- the agents constitution should be automatically marked as mandatory reads in the agents prompts generated/composed, same for validators
- not sure if the orchestrator constitution should be passed as the system prompt when starting a new session with "edison session start"/pasted/passed as the first message OR if we should keep maintainng a separate SESSION.START prompt, as I think that maybe we could have multiple "START" prompts (to be able to start a new session which resumes a previous one, OR a session which automatically take some tasks not claimed and in "todo" to start working on them, OR start a session which waits for the user to give us some tasks, etc) and keep only the common main loop/logic in the guidelines/orchestrators/SESSION_WORKFLOW. 
- We should also clearly indicate automatically in each composed agent/validator constitution the type that they are (agent/validator) AND where they find their constitution, which should be RE-READ completely on each compaction/new session
- Same for orchestrators, we should clearly indicate in the orchestrator constitution file where they can find this file and to RE-READ it MANDATORILY on each new session/compact
- maybe we could even add a claude hook to reiterate this before/after each compact, automatically based on the agent type (orchestrator/validator/agent)

Your plan in /Users/leeroy/Documents/Development/edison/PHASE_PRE-EDISON_MIGRATION_1_NEW_ANALYSIS.mdshould be as detailled and precise as possible, and should include EVERYTHING discussed here as well as everything uncovered by te validators. We should ONLY list tasks/changes/refactors needed and mising sections/files/logic/scripts/etc and NOT list what is already correct for example, to keep context light and focus on WHAT we need to do exactly.

Please start by updating the /Users/leeroy/Documents/Development/edison/PHASE_PRE-EDISON_MIGRATION_1_NEW_ANALYSIS.md document with all of the above if necessary, and ONLY THEN, start delegating to the new subagents and then iterate like this (delegating, analysing the reports/results, updating the plan, delegating, analysing the reports/results, etc)
"""Tests for `edison compose commands` CLI.

NO MOCKS - real subprocess calls, real file I/O, real CLI execution.
"""
from __future__ import annotations

import json
import os
import subprocess
import sys
from pathlib import Path


def _base_env(project_root: Path) -> dict[str, str]:
    env = os.environ.copy()
    env["AGENTS_PROJECT_ROOT"] = str(project_root)
    env.setdefault("PYTHONPATH", os.getcwd() + "/src")
    return env


def run_compose_commands(args: list[str], *, env: dict[str, str], cwd: Path) -> subprocess.CompletedProcess:
    cmd = [sys.executable, "-m", "edison.cli.compose.commands", *args]
    return subprocess.run(
        cmd,
        text=True,
        capture_output=True,
        env=env,
        cwd=cwd,
        check=False,
    )


def test_compose_commands_list_json_succeeds(tmp_path: Path) -> None:
    project = tmp_path / "project"
    project.mkdir()

    result = run_compose_commands(["--list", "--json", "--repo-root", str(project)], env=_base_env(project), cwd=project)
    assert result.returncode == 0, f"Command failed:\n{result.stdout}\n{result.stderr}"

    payload = json.loads(result.stdout)
    assert isinstance(payload, dict)
    assert "commands" in payload
    assert any(c.get("id") == "session-next" for c in payload["commands"])


def test_compose_commands_writes_claude_commands(tmp_path: Path) -> None:
    project = tmp_path / "project"
    project.mkdir()

    out_dir = project / ".claude" / "commands"
    args = ["--platform", "claude", "--repo-root", str(project)]
    result = run_compose_commands(args, env=_base_env(project), cwd=project)
    assert result.returncode == 0, f"Command failed:\n{result.stdout}\n{result.stderr}"

    # File name should respect platform prefix from commands.yaml ("edison-").
    cmd_file = out_dir / "edison-session-next.md"
    assert cmd_file.exists(), f"Expected command file at {cmd_file}"

    text = cmd_file.read_text(encoding="utf-8")
    # Claude SlashCommand tool only indexes commands with a description.
    assert "description:" in text
    assert "edison-generated: true" in text
    # Edison default: commands are workflow guidance, not auto-executed bash.
    assert "edison session next <session_id>" in text
    assert "!edison session next <session_id>" not in text
    assert "argument-hint:" in text

    # Commands with args should expose an argument hint for ergonomics.
    claim_file = out_dir / "edison-task-claim.md"
    assert claim_file.exists(), f"Expected command file at {claim_file}"
    claim_text = claim_file.read_text(encoding="utf-8")
    assert "argument-hint:" in claim_text
    assert "record_id" in claim_text
    assert "edison task claim <record_id>" in claim_text

    status_file = out_dir / "edison-task-status.md"
    assert status_file.exists(), f"Expected command file at {status_file}"
    status_text = status_file.read_text(encoding="utf-8")
    assert "edison task status <record_id>" in status_text


def test_compose_commands_writes_cursor_commands(tmp_path: Path) -> None:
    project = tmp_path / "project"
    project.mkdir()

    out_dir = project / ".cursor" / "commands"
    args = ["--platform", "cursor", "--repo-root", str(project)]
    result = run_compose_commands(args, env=_base_env(project), cwd=project)
    assert result.returncode == 0, f"Command failed:\n{result.stdout}\n{result.stderr}"

    cmd_file = out_dir / "edison-session-next.md"
    assert cmd_file.exists(), f"Expected command file at {cmd_file}"
    text = cmd_file.read_text(encoding="utf-8")
    assert "EDISON:GENERATED" in text
    assert "edison session next <session_id>" in text


def test_compose_commands_default_selection_excludes_optional_domains(tmp_path: Path) -> None:
    project = tmp_path / "project"
    project.mkdir()

    out_dir = project / ".claude" / "commands"
    args = ["--platform", "claude", "--repo-root", str(project)]
    result = run_compose_commands(args, env=_base_env(project), cwd=project)
    assert result.returncode == 0, f"Command failed:\n{result.stdout}\n{result.stderr}"

    # Default Edison config should keep the slash-command catalog small:
    # - Long-term memory is optional and should not be generated by default.
    assert not (out_dir / "edison-memory-search.md").exists()

    # "Validate current" is not a real Edison CLI entrypoint (QA validation requires a task_id).
    assert not (out_dir / "edison-validate-now.md").exists()

    # Advanced START_* prompts exist, but are not in the default slash-command set.
    assert not (out_dir / "edison-start-cleanup.md").exists()


def test_compose_commands_cli_snippets_are_copy_pasteable(tmp_path: Path) -> None:
    project = tmp_path / "project"
    project.mkdir()

    out_dir = project / ".claude" / "commands"
    args = ["--platform", "claude", "--repo-root", str(project)]
    result = run_compose_commands(args, env=_base_env(project), cwd=project)
    assert result.returncode == 0, f"Command failed:\n{result.stdout}\n{result.stderr}"

    for path in out_dir.glob("*.md"):
        text = path.read_text(encoding="utf-8")
        assert "$1" not in text, f"Unexpected positional token in {path.name}"

    task_new_text = (out_dir / "edison-task-new.md").read_text(encoding="utf-8")
    assert "--description" not in task_new_text

    start_new_text = (out_dir / "edison-start-new-session.md").read_text(encoding="utf-8")
    assert "edison compose all --start" in start_new_text


def test_compose_commands_prunes_stale_generated_files(tmp_path: Path) -> None:
    project = tmp_path / "project"
    project.mkdir()

    out_dir = project / ".claude" / "commands"
    out_dir.mkdir(parents=True, exist_ok=True)

    stale_generated = out_dir / "edison-stale-generated.md"
    stale_generated.write_text(
        "---\n"
        "description: \"stale\"\n"
        "edison-generated: true\n"
        "---\n"
        "\n"
        "# stale\n",
        encoding="utf-8",
    )
    assert stale_generated.exists()

    stale_legacy_generated = out_dir / "edison-stale-legacy.md"
    stale_legacy_generated.write_text(
        "---\n"
        "description: \"legacy\"\n"
        "---\n"
        "\n"
        "# edison-stale-legacy\n"
        "\n"
        "## Related Commands\n"
        "- /edison-session-next\n",
        encoding="utf-8",
    )
    assert stale_legacy_generated.exists()

    keep_user_file = out_dir / "edison-keep-user.md"
    keep_user_file.write_text("# user file\n", encoding="utf-8")
    assert keep_user_file.exists()

    args = ["--platform", "claude", "--repo-root", str(project)]
    result = run_compose_commands(args, env=_base_env(project), cwd=project)
    assert result.returncode == 0, f"Command failed:\n{result.stdout}\n{result.stderr}"

    assert not stale_generated.exists(), "Expected Edison to prune stale generated command file"
    assert not stale_legacy_generated.exists(), "Expected Edison to prune stale legacy Edison command file"
    assert keep_user_file.exists(), "Expected Edison not to delete user-created command files"

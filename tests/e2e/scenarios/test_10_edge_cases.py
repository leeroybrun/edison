"""Test 10: Edge Cases and Error Handling (REAL CLI)

All tests in this file execute REAL Edison CLI commands via
`helpers.command_runner.run_script`. No mock helpers are used to create files
or state; when corruption is needed, we mutate the real files generated by the
CLIs to simulate edge conditions.

Covered edge/error scenarios (using real CLIs):
- Missing evidence / readiness guards
- Invalid/missing arguments
- Invalid state transitions
- Orphaned QA or tasks
- Duplicate/archived session behaviors
- Empty/null values and malformed JSON
- Invalid file paths and permission errors
- ID formats and long slugs
"""
from __future__ import annotations

import json
import pytest
from pathlib import Path

from helpers import TestProjectDir, TestGitRepo
from helpers.assertions import (
    assert_file_exists,
    assert_file_not_exists,
)
from helpers.command_runner import (
    run_script,
    assert_command_success,
    assert_command_failure,
    assert_output_contains,
    assert_error_contains,
    assert_json_output,
)
from edison.core.utils.text import format_frontmatter


@pytest.mark.edge_case
@pytest.mark.fast
def test_task_missing_required_metadata(project_dir: TestProjectDir):
    """tasks/ready should fail when evidence/metadata is missing."""
    num, wave, slug = "100", "wave1", "missing-meta"
    task_id = f"{num}-{wave}-{slug}"

    # Create a real task via CLI
    result = run_script(
        "tasks/new",
        ["--id", num, "--wave", wave, "--slug", slug],
        cwd=project_dir.tmp_path,
    )
    assert_command_success(result)

    # Guard should fail (no evidence / reports)
    guard = run_script(
        "tasks/ready",
        [task_id],
        cwd=project_dir.tmp_path,
    )
    assert_command_failure(guard)
    # Error message varies; document failure only


@pytest.mark.edge_case
@pytest.mark.fast
def test_session_malformed_json(project_dir: TestProjectDir):
    """session status should fail to load malformed session JSON."""
    session_id = "test-malformed"

    # Create a real session then corrupt it
    created = run_script(
        "session",
        ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"],
        cwd=project_dir.tmp_path,
    )
    assert_command_success(created)

    session_path = project_dir.project_root / "sessions" / "wip" / session_id / "session.json"
    assert_file_exists(session_path)
    session_path.write_text('{"sessionId": "test-malformed", invalid json')

    # Now the CLI should fail to read it
    status = run_script(
        "session",
        ["status", session_id, "--json"],
        cwd=project_dir.tmp_path,
    )
    assert_command_failure(status)


@pytest.mark.edge_case
@pytest.mark.fast
def test_task_id_with_special_characters(project_dir: TestProjectDir):
    """tasks/new supports dotted numeric slots for children/grandchildren."""
    cases = [
        ("100", "wave1", "test"),
        ("150.1", "wave1", "child"),
        ("200.1.1", "wave1", "grandchild"),
    ]
    for num, wave, slug in cases:
        task_id = f"{num}-{wave}-{slug}"
        res = run_script(
            "tasks/new",
            ["--id", num, "--wave", wave, "--slug", slug],
            cwd=project_dir.tmp_path,
        )
        assert_command_success(res)
        path = project_dir.project_root / "tasks" / "todo" / f"{task_id}.md"
        assert_file_exists(path)


@pytest.mark.edge_case
@pytest.mark.fast
def test_empty_evidence_directory(project_dir: TestProjectDir):
    """validators/validate fails when evidence dir has no round files."""
    num, wave, slug = "150", "wave1", "empty-evidence"
    task_id = f"{num}-{wave}-{slug}"

    # QA must be attached to an existing task.
    task = run_script(
        "tasks/new",
        ["--id", num, "--wave", wave, "--slug", slug],
        cwd=project_dir.tmp_path,
    )
    assert_command_success(task)

    # Create QA (creates evidence root .project/qa/validation-evidence/<task_id>/)
    qa = run_script(
        "qa/new",
        [task_id],
        cwd=project_dir.tmp_path,
    )
    assert_command_success(qa)

    evidence_root = project_dir.project_root / "qa" / "validation-evidence" / task_id

    validate = run_script(
        "validators/validate",
        [task_id, "--execute"],
        cwd=project_dir.tmp_path,
    )
    assert_command_failure(validate)
    assert any(evidence_root.glob("round-*"))


@pytest.mark.edge_case
@pytest.mark.fast
def test_orphaned_task_no_owner(project_dir: TestProjectDir):
    """tasks/list should show _unassigned_ owner until task is claimed."""
    num, wave, slug = "200", "wave1", "orphaned"
    task_id = f"{num}-{wave}-{slug}"

    # Create task without --owner
    res = run_script(
        "tasks/new",
        ["--id", num, "--wave", wave, "--slug", slug],
        cwd=project_dir.tmp_path,
    )
    assert_command_success(res)

    # List records and verify owner is _unassigned_
    listing = run_script("tasks/list", ["--json"], cwd=project_dir.tmp_path)
    assert_command_success(listing)
    items = assert_json_output(listing)
    entry = next((r for r in items if r["id"] == task_id and r["type"] == "task"), None)
    assert entry is not None
    assert entry.get("owner") in {None, "_unassigned_"}


@pytest.mark.edge_case
@pytest.mark.fast
def test_orphaned_qa_no_task(project_dir: TestProjectDir):
    """qa/promote should fail when the QA record does not exist.

    QA records are created alongside tasks (single source of truth).
    """
    task_id = "250-wave1-orphaned"

    # qa/new must fail when the task does not exist (fail-closed)
    qa = run_script("qa/new", [task_id], cwd=project_dir.tmp_path)
    assert_command_failure(qa)
    assert_error_contains(qa, "Task not found")


@pytest.mark.edge_case
@pytest.mark.fast
def test_session_no_tasks_list(project_dir: TestProjectDir):
    """session status returns JSON; duplicate creation fails."""
    session_id = "test-no-tasks-array"

    created = run_script(
        "session",
        ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"],
        cwd=project_dir.tmp_path,
    )
    assert_command_success(created)

    # Duplicate session creation should fail
    dup = run_script(
        "session",
        ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"],
        cwd=project_dir.tmp_path,
    )
    assert_command_failure(dup)
    assert_error_contains(dup, "already exists")

    status = run_script("session", ["status", session_id, "--json"], cwd=project_dir.tmp_path)
    assert_command_success(status)
    data = assert_json_output(status)
    assert data.get("tasks") in (None, {})


@pytest.mark.edge_case
@pytest.mark.fast
def test_task_duplicate_filenames_different_states(project_dir: TestProjectDir):
    """Simulate duplicate task files across states and verify both exist."""
    num, wave, slug = "300", "wave1", "duplicate"
    task_id = f"{num}-{wave}-{slug}"

    # Create task in todo via CLI
    res = run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug], cwd=project_dir.tmp_path)
    assert_command_success(res)

    # Manually copy to wip to simulate duplicate (no mock data creation; copy real CLI output)
    todo_path = project_dir.project_root / "tasks" / "todo" / f"{task_id}.md"
    wip_path = project_dir.project_root / "tasks" / "wip" / f"{task_id}.md"
    wip_path.parent.mkdir(parents=True, exist_ok=True)
    from helpers.assertions import read_file
    wip_path.write_text(read_file(todo_path))

    assert_file_exists(todo_path)
    assert_file_exists(wip_path)


@pytest.mark.edge_case
@pytest.mark.fast
def test_evidence_missing_required_files(project_dir: TestProjectDir):
    """validators/validate reports missing required validator reports."""
    num, wave, slug = "350", "wave1", "incomplete-evidence"
    task_id = f"{num}-{wave}-{slug}"

    # QA must be attached to an existing task.
    task = run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug], cwd=project_dir.tmp_path)
    assert_command_success(task)

    # Create QA to seed evidence root
    qa = run_script("qa/new", [task_id], cwd=project_dir.tmp_path)
    assert_command_success(qa)

    # Prepare round-1 with only SOME required validator reports (others missing)
    round_dir = project_dir.project_root / "qa" / "validation-evidence" / task_id / "round-1"
    round_dir.mkdir(parents=True, exist_ok=True)

    def write_report(validator_id: str, model: str, verdict: str = "approve") -> None:
        payload = {
            "taskId": task_id,
            "round": 1,
            "validatorId": validator_id,
            "model": model,
            "verdict": verdict,
            "tracking": {"processId": 12345, "startedAt": "2025-01-01T00:00:00Z"},
        }
        (round_dir / f"validator-{validator_id}-report.md").write_text(
            format_frontmatter(payload) + "\n",
            encoding="utf-8",
        )

    write_report("global-codex", "codex")
    write_report("global-claude", "claude")
    # Create *present but not approved* blocking reports to avoid executing external CLIs.
    write_report("security", "codex", verdict="pending")
    write_report("performance", "codex", verdict="pending")

    res = run_script("validators/validate", [task_id, "--check-only", "--blocking-only"], cwd=project_dir.tmp_path)
    assert_command_failure(res)
    assert_output_contains(res, "Bundle NOT approved", in_stderr=False)
    assert_output_contains(res, "performance", in_stderr=False)
    assert_output_contains(res, "security", in_stderr=False)


@pytest.mark.edge_case
@pytest.mark.fast
def test_very_long_task_id(project_dir: TestProjectDir):
    """tasks/new supports long slugs (file path should be created)."""
    num, wave = "400", "wave1"
    slug = "very-long-slug-" * 10
    task_id = f"{num}-{wave}-{slug}"

    res = run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug], cwd=project_dir.tmp_path)
    assert_command_success(res)
    path = project_dir.project_root / "tasks" / "todo" / f"{task_id}.md"
    assert_file_exists(path)


@pytest.mark.edge_case
@pytest.mark.fast
def test_task_in_blocked_state_with_reason(project_dir: TestProjectDir):
    """Invalid direct todo→blocked transition fails; wip→blocked succeeds."""
    num, wave, slug = "450", "wave1", "blocked-reason"
    task_id = f"{num}-{wave}-{slug}"

    # Create session + task
    session_id = "blocked-reason-session"
    assert_command_success(
        run_script("session", ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"], cwd=project_dir.tmp_path)
    )
    assert_command_success(
        run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug], cwd=project_dir.tmp_path)
    )

    # Invalid transition: todo → done should fail
    bad = run_script("tasks/status", [task_id, "--status", "done"], cwd=project_dir.tmp_path)
    assert_command_failure(bad)

    # Valid path: claim to wip → blocked (with explicit blocker reason)
    assert_command_success(run_script("tasks/claim", [task_id, "--session", session_id], cwd=project_dir.tmp_path))
    to_blocked = run_script(
        "tasks/status",
        [task_id, "--status", "blocked", "--reason", "waiting on external dependency"],
        cwd=project_dir.tmp_path,
    )
    assert_command_success(to_blocked)
    assert_output_contains(to_blocked, "blocked")


@pytest.mark.edge_case
@pytest.mark.fast
def test_session_with_archived_worktree_path(project_dir: TestProjectDir):
    """Session JSON can reference archived worktree paths; status still loads."""
    session_id = "test-archived-wt"

    res = run_script(
        "session",
        ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"],
        cwd=project_dir.tmp_path,
    )
    assert_command_success(res)

    session_path = project_dir.project_root / "sessions" / "wip" / session_id / "session.json"
    data = json.loads(session_path.read_text())
    data.setdefault("git", {})["worktreePath"] = str(project_dir.tmp_path / ".worktrees" / "_archived" / session_id)
    session_path.write_text(json.dumps(data, indent=2))

    status = run_script("session", ["status", session_id, "--json"], cwd=project_dir.tmp_path)
    assert_command_success(status)
    loaded = assert_json_output(status)
    assert "_archived" in loaded.get("git", {}).get("worktreePath", "")


@pytest.mark.edge_case
@pytest.mark.fast
def test_qa_bypass_without_type_flag_blocked(project_dir: TestProjectDir):
    """SECURITY: tasks/status must not allow QA transitions even if --type is omitted.

    Regression for guard that previously checked args.type == "qa" and
    could be bypassed by omitting --type. The guard must use the resolved
    record_type instead.
    """
    num, wave, slug = "501", "wave1", "qa-bypass-guard"
    task_id = f"{num}-{wave}-{slug}"
    qa_id = f"{task_id}-qa"

    # Create task (creates QA record as the single source of truth)
    created = run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug], cwd=project_dir.tmp_path)
    assert_command_success(created)

    # Attempt to change QA status via tasks/status WITHOUT --type should fail
    # (record type must be resolved, not read from the --type flag).
    res = run_script("tasks/status", [qa_id, "--status", "done"], cwd=project_dir.tmp_path)
    assert_command_failure(res)
    assert_error_contains(res, "QA state transitions must use edison qa promote")


@pytest.mark.edge_case
@pytest.mark.fast
def test_multiple_qa_rounds_same_task(project_dir: TestProjectDir):
    """qa/round appends round history across runs."""
    num, wave, slug = "500", "wave1", "multi-qa"
    task_id = f"{num}-{wave}-{slug}"

    # Create task (creates QA record as the single source of truth)
    assert_command_success(run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug], cwd=project_dir.tmp_path))

    # Append multiple rounds via real CLI
    for i in range(1, 4):
        round_res = run_script("qa/round", [task_id, "--status", "approve", "--note", f"r{i}"], cwd=project_dir.tmp_path)
        assert_command_success(round_res)

    qa_path = project_dir.project_root / "qa" / "waiting" / f"{task_id}-qa.md"
    from helpers.assertions import read_file
    text = read_file(qa_path)
    assert "round_history" in text
    assert "r1" in text and "r2" in text and "r3" in text


@pytest.mark.edge_case
@pytest.mark.fast
def test_task_parent_does_not_exist(project_dir: TestProjectDir):
    """tasks/new allows --parent referencing a non-existent parent (later guards catch it)."""
    parent_id = "600-wave1-missing-parent"
    child_num, wave, slug = "600.1", "wave1", "orphan-child"
    child_id = f"{child_num}-{wave}-{slug}"

    created = run_script(
        "tasks/new",
        ["--id", child_num, "--wave", wave, "--slug", slug, "--parent", parent_id],
        cwd=project_dir.tmp_path,
    )
    assert_command_success(created)

    child_path = project_dir.project_root / "tasks" / "todo" / f"{child_id}.md"
    assert_file_exists(child_path)
    from helpers.assertions import read_file
    assert parent_id in read_file(child_path)


@pytest.mark.edge_case
@pytest.mark.worktree
@pytest.mark.requires_git
def test_worktree_path_does_not_exist(project_dir: TestProjectDir):
    """Session JSON can point to non-existent worktree; path check remains OS-level."""
    session_id = "test-missing-wt"
    res = run_script(
        "session",
        ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"],
        cwd=project_dir.tmp_path,
    )
    assert_command_success(res)

    fake_path = project_dir.tmp_path / ".worktrees" / "non-existent"
    sess_path = project_dir.project_root / "sessions" / "wip" / session_id / "session.json"
    data = json.loads(sess_path.read_text())
    data.setdefault("git", {})["worktreePath"] = str(fake_path)
    sess_path.write_text(json.dumps(data, indent=2))

    # Status still loads; the path simply doesn't exist on disk
    status = run_script("session", ["status", session_id, "--json"], cwd=project_dir.tmp_path)
    assert_command_success(status)
    assert not fake_path.exists()


@pytest.mark.edge_case
@pytest.mark.fast
def test_empty_task_file(project_dir: TestProjectDir):
    """tasks/claim should fail to stamp metadata on an empty task file."""
    num, wave, slug = "700", "wave1", "empty"
    task_id = f"{num}-{wave}-{slug}"

    # Create via CLI then deliberately clear file to simulate corruption
    run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug], cwd=project_dir.tmp_path)
    path = project_dir.project_root / "tasks" / "todo" / f"{task_id}.md"
    path.write_text("")
    assert_file_exists(path)

    # Claim by record ID; the repository should fail closed on malformed files.
    session_id = "empty-task-session"
    assert_command_success(
        run_script("session", ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"], cwd=project_dir.tmp_path)
    )
    claim = run_script("tasks/claim", [task_id, "--session", session_id], cwd=project_dir.tmp_path)
    assert_command_failure(claim)
    assert_error_contains(claim, "frontmatter")


@pytest.mark.edge_case
@pytest.mark.fast
def test_context7_evidence_without_task(project_dir: TestProjectDir):
    """validators/validate roster-only mode tolerates orphan evidence roots (no rounds)."""
    task_id = "750-wave1-ctx7-orphan"

    # Create orphan evidence directory with a context7 note but no rounds
    ev_root = project_dir.project_root / "qa" / "validation-evidence" / task_id
    ev_root.mkdir(parents=True, exist_ok=True)
    (ev_root / "context7-react.txt").write_text("Context7 evidence placeholder\n")

    res = run_script("validators/validate", [task_id], cwd=project_dir.tmp_path)
    assert_command_success(res)
    assert_output_contains(res, f"Validation roster for {task_id}:", in_stderr=False)
    assert_output_contains(res, "To execute validators, add --execute flag", in_stderr=False)


@pytest.mark.edge_case
@pytest.mark.fast
def test_session_invalid_state_directory(project_dir: TestProjectDir):
    """session status fails when the session file lives under an unknown state directory."""
    session_id = "test-invalid-state"

    invalid_dir = project_dir.project_root / "sessions" / "invalid" / session_id
    invalid_dir.mkdir(parents=True, exist_ok=True)
    (invalid_dir / "session.json").write_text(json.dumps({
        "meta": {"sessionId": session_id, "owner": "tester", "status": "invalid", "mode": "start", "createdAt": "2025-01-01T00:00:00Z", "lastActive": "2025-01-01T00:00:00Z"},
        "tasks": {},
        "qa": {},
        "activityLog": [{"timestamp": "2025-01-01T00:00:00Z", "message": "init"}]
    }, indent=2))

    status = run_script("session", ["status", session_id, "--json"], cwd=project_dir.tmp_path)
    assert_command_failure(status)
    # In JSON mode, CLI errors are emitted to stdout as machine-readable payloads.
    assert_output_contains(status, "not found", in_stderr=False)


@pytest.mark.edge_case
@pytest.mark.fast
def test_circular_task_dependency(project_dir: TestProjectDir):
    """tasks/ready detects cycles in session task graph (via guards)."""
    # Create session
    session_id = "cycle-session"
    run_script("session", ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"], cwd=project_dir.tmp_path)

    # Create two tasks and claim them into session
    task_a = ("800", "wave1", "task-a")
    task_b = ("800.1", "wave1", "task-b")
    for num, wave, slug in (task_a, task_b):
        rid = f"{num}-{wave}-{slug}"
        assert_command_success(run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug, "--session", session_id], cwd=project_dir.tmp_path))
        assert_command_success(run_script("tasks/claim", [rid, "--session", session_id], cwd=project_dir.tmp_path))

    id_a = f"{task_a[0]}-{task_a[1]}-{task_a[2]}"
    id_b = f"{task_b[0]}-{task_b[1]}-{task_b[2]}"

    # Link A → B and B → A (cycle) via real CLI
    assert_command_success(run_script("tasks/link", [id_a, id_b, "--session", session_id, "--force"], cwd=project_dir.tmp_path))
    assert_command_success(run_script("tasks/link", [id_b, id_a, "--session", session_id, "--force"], cwd=project_dir.tmp_path))

    # Provide minimal readiness artefacts so tasks/ready reaches cycle check
    ev_root = project_dir.project_root / "qa" / "validation-evidence" / id_a / "round-1"
    ev_root.mkdir(parents=True, exist_ok=True)
    for f in ("command-type-check.txt", "command-lint.txt", "command-test.txt", "command-build.txt"):
        (ev_root / f).write_text("ok\n")
    impl = {
        "taskId": id_a,
        "round": 1,
        "implementationApproach": "orchestrator-direct",
        "primaryModel": "codex",
        "completionStatus": "complete",
        "followUpTasks": [],
        "notesForValidator": "cycle check",
        "tracking": {"processId": 1, "startedAt": "2025-01-01T00:00:00Z", "completedAt": "2025-01-01T00:10:00Z"}
    }
    (ev_root / "implementation-report.md").write_text(format_frontmatter(impl) + "\n", encoding="utf-8")

    # tasks/ready should fail with cycle detection
    ready = run_script("tasks/ready", [id_a, "--session", session_id], cwd=project_dir.tmp_path)
    assert_command_failure(ready)
    assert_error_contains(ready, "Cycle detected")


@pytest.mark.edge_case
@pytest.mark.fast
@pytest.mark.security
def test_qa_guard_bypass_via_tasks_status(project_dir: TestProjectDir):
    """tasks/status with --type qa should reject transitions and redirect to qa/promote.

    SECURITY: This prevents bypassing validator consensus by using tasks/status
    to directly move QA files between states without validation checks.
    """
    num, wave, slug = "850", "wave1", "bypass-test"
    task_id = f"{num}-{wave}-{slug}"
    qa_id = f"{task_id}-qa"

    # Create task (creates QA record in waiting)
    created = run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug], cwd=project_dir.tmp_path)
    assert_command_success(created)

    # Verify QA exists in waiting
    qa_path = project_dir.project_root / "qa" / "waiting" / f"{qa_id}.md"
    assert_file_exists(qa_path)

    # Attempt to bypass validators using tasks/status with --type qa
    # This should be REJECTED with clear error message
    bypass_attempt = run_script(
        "tasks/status",
        [qa_id, "--type", "qa", "--status", "done"],
        cwd=project_dir.tmp_path,
    )

    # CRITICAL: Must fail to prevent security bypass
    assert_command_failure(bypass_attempt)
    assert_error_contains(bypass_attempt, "QA state transitions must use")
    assert_error_contains(bypass_attempt, "qa/promote")

    # Verify QA file NOT moved to done (still in waiting)
    assert_file_exists(qa_path)
    done_path = project_dir.project_root / "qa" / "done" / f"{qa_id}.md"
    assert_file_not_exists(done_path)

"""Test 10: Edge Cases and Error Handling (REAL CLI)

All tests in this file execute REAL Edison CLI commands via
`helpers.command_runner.run_script`. No mock helpers are used to create files
or state; when corruption is needed, we mutate the real files generated by the
CLIs to simulate edge conditions.

Covered edge/error scenarios (using real CLIs):
- Missing evidence / readiness guards
- Invalid/missing arguments
- Invalid state transitions
- Orphaned QA or tasks
- Duplicate/archived session behaviors
- Empty/null values and malformed JSON
- Invalid file paths and permission errors
- ID formats and long slugs
"""
from __future__ import annotations

import json
import pytest
from pathlib import Path

from helpers import TestProjectDir, TestGitRepo
from helpers.assertions import (
    assert_file_exists,
    assert_file_not_exists,
)
from helpers.command_runner import (
    run_script,
    assert_command_success,
    assert_command_failure,
    assert_output_contains,
    assert_error_contains,
    assert_json_output,
)


@pytest.mark.edge_case
@pytest.mark.fast
def test_task_missing_required_metadata(test_project_dir: TestProjectDir):
    """tasks/ready should fail when evidence/metadata is missing."""
    num, wave, slug = "100", "wave1", "missing-meta"
    task_id = f"{num}-{wave}-{slug}"

    # Create a real task via CLI
    result = run_script(
        "tasks/new",
        ["--id", num, "--wave", wave, "--slug", slug],
        cwd=test_project_dir.tmp_path,
    )
    assert_command_success(result)

    # Guard should fail (no evidence / reports)
    guard = run_script(
        "tasks/ready",
        [task_id],
        cwd=test_project_dir.tmp_path,
    )
    assert_command_failure(guard)
    # Error message varies; document failure only


@pytest.mark.edge_case
@pytest.mark.fast
def test_session_malformed_json(test_project_dir: TestProjectDir):
    """session status should fail to load malformed session JSON."""
    session_id = "test-malformed"

    # Create a real session then corrupt it
    created = run_script(
        "session",
        ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"],
        cwd=test_project_dir.tmp_path,
    )
    assert_command_success(created)

    session_path = test_project_dir.project_root / "sessions" / "wip" / f"{session_id}.json"
    assert_file_exists(session_path)
    session_path.write_text('{"sessionId": "test-malformed", invalid json')

    # Now the CLI should fail to read it
    status = run_script(
        "session",
        ["status", session_id, "--json"],
        cwd=test_project_dir.tmp_path,
    )
    assert_command_failure(status)


@pytest.mark.edge_case
@pytest.mark.fast
def test_task_id_with_special_characters(test_project_dir: TestProjectDir):
    """tasks/new supports dotted numeric slots for children/grandchildren."""
    cases = [
        ("100", "wave1", "test"),
        ("150.1", "wave1", "child"),
        ("200.1.1", "wave1", "grandchild"),
    ]
    for num, wave, slug in cases:
        task_id = f"{num}-{wave}-{slug}"
        res = run_script(
            "tasks/new",
            ["--id", num, "--wave", wave, "--slug", slug],
            cwd=test_project_dir.tmp_path,
        )
        assert_command_success(res)
        path = test_project_dir.project_root / "tasks" / "todo" / f"{task_id}.md"
        assert_file_exists(path)


@pytest.mark.edge_case
@pytest.mark.fast
def test_empty_evidence_directory(test_project_dir: TestProjectDir):
    """validators/validate fails when evidence dir has no round files."""
    num, wave, slug = "150", "wave1", "empty-evidence"
    task_id = f"{num}-{wave}-{slug}"

    # Create QA (creates evidence root .project/qa/validation-evidence/<task_id>/)
    qa = run_script(
        "qa/new",
        [task_id],
        cwd=test_project_dir.tmp_path,
    )
    assert_command_success(qa)

    # Run validator bundle check → should fail: No round-* dirs
    validate = run_script(
        "validators/validate",
        ["--task", task_id],
        cwd=test_project_dir.tmp_path,
    )
    assert_command_failure(validate)
    assert_output_contains(validate, "No round directories", in_stderr=False)


@pytest.mark.edge_case
@pytest.mark.fast
def test_orphaned_task_no_owner(test_project_dir: TestProjectDir):
    """tasks/list should show _unassigned_ owner until task is claimed."""
    num, wave, slug = "200", "wave1", "orphaned"
    task_id = f"{num}-{wave}-{slug}"

    # Create task without --owner
    res = run_script(
        "tasks/new",
        ["--id", num, "--wave", wave, "--slug", slug],
        cwd=test_project_dir.tmp_path,
    )
    assert_command_success(res)

    # List records and verify owner is _unassigned_
    listing = run_script("tasks/list", ["--format", "json"], cwd=test_project_dir.tmp_path)
    assert_command_success(listing)
    items = assert_json_output(listing)
    entry = next((r for r in items if r["id"] == task_id and r["type"] == "task"), None)
    assert entry is not None
    assert entry.get("owner") in {None, "_unassigned_"}


@pytest.mark.edge_case
@pytest.mark.fast
def test_orphaned_qa_no_task(test_project_dir: TestProjectDir):
    """qa/promote waiting→todo should fail when parent task is missing."""
    task_id = "250-wave1-orphaned"

    # Create QA for a non-existent task (allowed by qa/new)
    qa = run_script("qa/new", [task_id], cwd=test_project_dir.tmp_path)
    assert_command_success(qa)

    # Promote waiting→todo should fail because the parent task doesn't exist/done
    promote = run_script("qa/promote", ["--task", task_id, "--to", "todo"], cwd=test_project_dir.tmp_path)
    assert_command_failure(promote)
    assert_error_contains(promote, "Cannot move QA waiting→todo")


@pytest.mark.edge_case
@pytest.mark.fast
def test_session_no_tasks_list(test_project_dir: TestProjectDir):
    """session status returns JSON with empty tasks; duplicate creation fails."""
    session_id = "test-no-tasks-array"

    created = run_script(
        "session",
        ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"],
        cwd=test_project_dir.tmp_path,
    )
    assert_command_success(created)

    # Duplicate session creation should fail
    dup = run_script(
        "session",
        ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"],
        cwd=test_project_dir.tmp_path,
    )
    assert_command_failure(dup)
    assert_error_contains(dup, "already exists")

    status = run_script("session", ["status", session_id, "--json"], cwd=test_project_dir.tmp_path)
    assert_command_success(status)
    data = assert_json_output(status)
    assert isinstance(data.get("tasks"), dict) and len(data["tasks"]) == 0


@pytest.mark.edge_case
@pytest.mark.fast
def test_task_duplicate_filenames_different_states(test_project_dir: TestProjectDir):
    """Simulate duplicate task files across states and verify both exist."""
    num, wave, slug = "300", "wave1", "duplicate"
    task_id = f"{num}-{wave}-{slug}"

    # Create task in todo via CLI
    res = run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug], cwd=test_project_dir.tmp_path)
    assert_command_success(res)

    # Manually copy to wip to simulate duplicate (no mock data creation; copy real CLI output)
    todo_path = test_project_dir.project_root / "tasks" / "todo" / f"{task_id}.md"
    wip_path = test_project_dir.project_root / "tasks" / "wip" / f"{task_id}.md"
    wip_path.parent.mkdir(parents=True, exist_ok=True)
    from helpers.assertions import read_file
    wip_path.write_text(read_file(todo_path))

    assert_file_exists(todo_path)
    assert_file_exists(wip_path)


@pytest.mark.edge_case
@pytest.mark.fast
def test_evidence_missing_required_files(test_project_dir: TestProjectDir):
    """validators/validate reports missing required validator reports."""
    num, wave, slug = "350", "wave1", "incomplete-evidence"
    task_id = f"{num}-{wave}-{slug}"

    # Create QA to seed evidence root
    qa = run_script("qa/new", [task_id], cwd=test_project_dir.tmp_path)
    assert_command_success(qa)

    # Prepare round-1 with only SOME required validator reports (others missing)
    round_dir = test_project_dir.project_root / "qa" / "validation-evidence" / task_id / "round-1"
    round_dir.mkdir(parents=True, exist_ok=True)

    def write_report(validator_id: str, model: str) -> None:
        payload = {
            "taskId": task_id,
            "round": 1,
            "validatorId": validator_id,
            "model": model,
            "verdict": "approve",
            "tracking": {"processId": 12345, "startedAt": "2025-01-01T00:00:00Z"},
        }
        (round_dir / f"validator-{validator_id}-report.json").write_text(json.dumps(payload))

    write_report("global-codex", "codex")
    write_report("global-claude", "claude")
    # Missing: security (codex), performance (codex)

    res = run_script("validators/validate", ["--task", task_id], cwd=test_project_dir.tmp_path)
    assert_command_failure(res)
    assert_output_contains(res, "missing report:")


@pytest.mark.edge_case
@pytest.mark.fast
def test_very_long_task_id(test_project_dir: TestProjectDir):
    """tasks/new supports long slugs (file path should be created)."""
    num, wave = "400", "wave1"
    slug = "very-long-slug-" * 10
    task_id = f"{num}-{wave}-{slug}"

    res = run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug], cwd=test_project_dir.tmp_path)
    assert_command_success(res)
    path = test_project_dir.project_root / "tasks" / "todo" / f"{task_id}.md"
    assert_file_exists(path)


@pytest.mark.edge_case
@pytest.mark.fast
def test_task_in_blocked_state_with_reason(test_project_dir: TestProjectDir):
    """Invalid direct todo→blocked transition fails; wip→blocked succeeds."""
    num, wave, slug = "450", "wave1", "blocked-reason"
    task_id = f"{num}-{wave}-{slug}"

    # Create task
    run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug], cwd=test_project_dir.tmp_path)

    # Invalid transition: todo → done should fail
    bad = run_script("tasks/status", [task_id, "--status", "done"], cwd=test_project_dir.tmp_path)
    assert_command_failure(bad)

    # Valid path: todo → wip → blocked
    to_wip = run_script("tasks/status", [task_id, "--status", "wip"], cwd=test_project_dir.tmp_path)
    assert_command_success(to_wip)
    to_blocked = run_script("tasks/status", [task_id, "--status", "blocked"], cwd=test_project_dir.tmp_path)
    assert_command_success(to_blocked)
    assert_output_contains(to_blocked, "blocked")


@pytest.mark.edge_case
@pytest.mark.fast
def test_session_with_archived_worktree_path(test_project_dir: TestProjectDir):
    """Session JSON can reference archived worktree paths; status still loads."""
    session_id = "test-archived-wt"

    res = run_script(
        "session",
        ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"],
        cwd=test_project_dir.tmp_path,
    )
    assert_command_success(res)

    session_path = test_project_dir.project_root / "sessions" / "wip" / f"{session_id}.json"
    data = json.loads(session_path.read_text())
    data.setdefault("git", {})["worktreePath"] = str(test_project_dir.tmp_path / ".worktrees" / "_archived" / session_id)
    session_path.write_text(json.dumps(data, indent=2))

    status = run_script("session", ["status", session_id, "--json"], cwd=test_project_dir.tmp_path)
    assert_command_success(status)
    loaded = assert_json_output(status)
    assert "_archived" in loaded.get("git", {}).get("worktreePath", "")


@pytest.mark.edge_case
@pytest.mark.fast
def test_qa_bypass_without_type_flag_blocked(test_project_dir: TestProjectDir):
    """SECURITY: tasks/status must not allow QA transitions even if --type is omitted.

    Regression for guard that previously checked args.type == "qa" and
    could be bypassed by omitting --type. The guard must use the resolved
    record_type instead.
    """
    task_id = "501-wave1-qa-bypass-guard"

    # Create QA brief via real CLI
    qa = run_script("qa/new", [task_id], cwd=test_project_dir.tmp_path)
    assert_command_success(qa)

    # Attempt to change QA status via tasks/status WITHOUT --type should fail
    res = run_script("tasks/status", [task_id, "--status", "done"], cwd=test_project_dir.tmp_path)
    assert_command_failure(res)
    assert_error_contains(res, "QA state transitions must use scripts/qa/promote")


@pytest.mark.edge_case
@pytest.mark.fast
def test_multiple_qa_rounds_same_task(test_project_dir: TestProjectDir):
    """qa/round appends Round N sections to QA brief across runs."""
    task_id = "500-wave1-multi-qa"

    # Create QA brief for task
    qa = run_script("qa/new", [task_id], cwd=test_project_dir.tmp_path)
    assert_command_success(qa)

    # Append multiple rounds via real CLI
    for i in range(1, 4):
        round_res = run_script("qa/round", ["--task", task_id, "--status", "approved", "--note", f"r{i}"], cwd=test_project_dir.tmp_path)
        assert_command_success(round_res)

    qa_path = test_project_dir.project_root / "qa" / "waiting" / f"{task_id}-qa.md"
    from helpers.assertions import read_file
    text = read_file(qa_path)
    assert "## Round 1 Validation" in text
    assert "## Round 2 Validation" in text
    assert "## Round 3 Validation" in text


@pytest.mark.edge_case
@pytest.mark.fast
def test_task_parent_does_not_exist(test_project_dir: TestProjectDir):
    """tasks/new allows --parent referencing a non-existent parent (later guards catch it)."""
    parent_id = "600-wave1-missing-parent"
    child_num, wave, slug = "600.1", "wave1", "orphan-child"
    child_id = f"{child_num}-{wave}-{slug}"

    created = run_script(
        "tasks/new",
        ["--id", child_num, "--wave", wave, "--slug", slug, "--parent", parent_id],
        cwd=test_project_dir.tmp_path,
    )
    assert_command_success(created)

    child_path = test_project_dir.project_root / "tasks" / "todo" / f"{child_id}.md"
    assert_file_exists(child_path)
    from helpers.assertions import read_file
    assert parent_id in read_file(child_path)


@pytest.mark.edge_case
@pytest.mark.worktree
@pytest.mark.requires_git
def test_worktree_path_does_not_exist(test_project_dir: TestProjectDir):
    """Session JSON can point to non-existent worktree; path check remains OS-level."""
    session_id = "test-missing-wt"
    res = run_script(
        "session",
        ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"],
        cwd=test_project_dir.tmp_path,
    )
    assert_command_success(res)

    fake_path = test_project_dir.tmp_path / ".worktrees" / "non-existent"
    sess_path = test_project_dir.project_root / "sessions" / "wip" / f"{session_id}.json"
    data = json.loads(sess_path.read_text())
    data.setdefault("git", {})["worktreePath"] = str(fake_path)
    sess_path.write_text(json.dumps(data, indent=2))

    # Status still loads; the path simply doesn't exist on disk
    status = run_script("session", ["status", session_id, "--json"], cwd=test_project_dir.tmp_path)
    assert_command_success(status)
    assert not fake_path.exists()


@pytest.mark.edge_case
@pytest.mark.fast
def test_empty_task_file(test_project_dir: TestProjectDir):
    """tasks/claim should fail to stamp metadata on an empty task file."""
    num, wave, slug = "700", "wave1", "empty"
    task_id = f"{num}-{wave}-{slug}"

    # Create via CLI then deliberately clear file to simulate corruption
    run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug], cwd=test_project_dir.tmp_path)
    path = test_project_dir.project_root / "tasks" / "todo" / f"{task_id}.md"
    path.write_text("")
    assert_file_exists(path)

    claim = run_script("tasks/claim", ["--path", str(path)], cwd=test_project_dir.tmp_path)
    assert_command_failure(claim)
    assert_output_contains(claim, "Could not update required fields", in_stderr=False)


@pytest.mark.edge_case
@pytest.mark.fast
def test_context7_evidence_without_task(test_project_dir: TestProjectDir):
    """validators/validate fails for task with orphan evidence (no rounds)."""
    task_id = "750-wave1-ctx7-orphan"

    # Create orphan evidence directory with a context7 note but no rounds
    ev_root = test_project_dir.project_root / "qa" / "validation-evidence" / task_id
    ev_root.mkdir(parents=True, exist_ok=True)
    (ev_root / "context7-react.txt").write_text("Context7 evidence placeholder\n")

    res = run_script("validators/validate", ["--task", task_id], cwd=test_project_dir.tmp_path)
    assert_command_failure(res)
    assert_output_contains(res, "No round directories")


@pytest.mark.edge_case
@pytest.mark.fast
def test_session_invalid_state_directory(test_project_dir: TestProjectDir):
    """session status fails when the session file lives under an unknown state directory."""
    session_id = "test-invalid-state"

    invalid_dir = test_project_dir.project_root / "sessions" / "invalid"
    invalid_dir.mkdir(parents=True, exist_ok=True)
    (invalid_dir / f"{session_id}.json").write_text(json.dumps({
        "meta": {"sessionId": session_id, "owner": "tester", "status": "invalid", "mode": "start", "createdAt": "2025-01-01T00:00:00Z", "lastActive": "2025-01-01T00:00:00Z"},
        "tasks": {},
        "qa": {},
        "activityLog": [{"timestamp": "2025-01-01T00:00:00Z", "message": "init"}]
    }, indent=2))

    status = run_script("session", ["status", session_id, "--json"], cwd=test_project_dir.tmp_path)
    assert_command_failure(status)
    assert_error_contains(status, "not found")


@pytest.mark.edge_case
@pytest.mark.fast
def test_circular_task_dependency(test_project_dir: TestProjectDir):
    """tasks/ready detects cycles in session task graph (via guards)."""
    # Create session
    session_id = "cycle-session"
    run_script("session", ["new", "--owner", "tester", "--session-id", session_id, "--mode", "start"], cwd=test_project_dir.tmp_path)

    # Create two tasks and claim them into session
    task_a = ("800", "wave1", "task-a")
    task_b = ("800.1", "wave1", "task-b")
    for num, wave, slug in (task_a, task_b):
        rid = f"{num}-{wave}-{slug}"
        assert_command_success(run_script("tasks/new", ["--id", num, "--wave", wave, "--slug", slug, "--session", session_id], cwd=test_project_dir.tmp_path))
        assert_command_success(run_script("tasks/claim", [rid, "--session", session_id], cwd=test_project_dir.tmp_path))

    id_a = f"{task_a[0]}-{task_a[1]}-{task_a[2]}"
    id_b = f"{task_b[0]}-{task_b[1]}-{task_b[2]}"

    # Link A → B and B → A (cycle) via real CLI
    assert_command_success(run_script("tasks/link", [id_a, id_b, "--session", session_id, "--force"], cwd=test_project_dir.tmp_path))
    assert_command_success(run_script("tasks/link", [id_b, id_a, "--session", session_id, "--force"], cwd=test_project_dir.tmp_path))

    # Provide minimal readiness artefacts so tasks/ready reaches cycle check
    ev_root = test_project_dir.project_root / "qa" / "validation-evidence" / id_a / "round-1"
    ev_root.mkdir(parents=True, exist_ok=True)
    for f in ("command-type-check.txt", "command-lint.txt", "command-test.txt", "command-build.txt"):
        (ev_root / f).write_text("ok\n")
    impl = {
        "taskId": id_a,
        "round": 1,
        "implementationApproach": "orchestrator-direct",
        "primaryModel": "codex",
        "completionStatus": "complete",
        "followUpTasks": [],
        "notesForValidator": "cycle check",
        "tracking": {"processId": 1, "startedAt": "2025-01-01T00:00:00Z", "completedAt": "2025-01-01T00:10:00Z"}
    }
    (ev_root / "implementation-report.json").write_text(json.dumps(impl))

    # tasks/ready should fail with cycle detection
    ready = run_script("tasks/ready", [id_a, "--session", session_id], cwd=test_project_dir.tmp_path)
    assert_command_failure(ready)
    assert_output_contains(ready, "Cycle detected", in_stderr=False)


@pytest.mark.edge_case
@pytest.mark.fast
@pytest.mark.security
def test_qa_guard_bypass_via_tasks_status(test_project_dir: TestProjectDir):
    """tasks/status with --type qa should reject transitions and redirect to qa/promote.

    SECURITY: This prevents bypassing validator consensus by using tasks/status
    to directly move QA files between states without validation checks.
    """
    task_id = "850-wave1-bypass-test"

    # Create QA in waiting state
    qa_result = run_script("qa/new", [task_id], cwd=test_project_dir.tmp_path)
    assert_command_success(qa_result)

    # Verify QA exists in waiting
    qa_path = test_project_dir.project_root / "qa" / "waiting" / f"{task_id}-qa.md"
    assert_file_exists(qa_path)

    # Attempt to bypass validators using tasks/status with --type qa
    # This should be REJECTED with clear error message
    bypass_attempt = run_script(
        "tasks/status",
        [task_id, "--type", "qa", "--status", "done"],
        cwd=test_project_dir.tmp_path,
    )

    # CRITICAL: Must fail to prevent security bypass
    assert_command_failure(bypass_attempt)
    assert_error_contains(bypass_attempt, "QA state transitions must use")
    assert_error_contains(bypass_attempt, "qa/promote")

    # Verify QA file NOT moved to done (still in waiting)
    assert_file_exists(qa_path)
    done_path = test_project_dir.project_root / "qa" / "done" / f"{task_id}-qa.md"
    assert_file_not_exists(done_path)
